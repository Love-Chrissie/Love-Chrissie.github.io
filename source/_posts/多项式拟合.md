---
title: 多项式拟合
abbrlink: 45428
date: 2018-10-09 18:04:19
categories: 机器学习
tags: 拟合
---

给定一个训练数据集：
$$T=\begin{Bmatrix}(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\end{Bmatrix}$$
其中，$x_i\in \mathbb{R}$是输入$x$的观测值，$y_i\in\mathbb{R}$是相应的输出$y$的观测值，$i=1,2,\cdots,N.$多项式拟合需要做的就是在$M$次多项式函数中选择一个对已知数据和未知数据都有很好的预测能力的函数。

设$M$次多项式函数为：

$$f_M(x,w)=w_0+w_1 x+w_2 x^2+\cdots+w_M x^M=\sum\limits_{j=0}^{M}w_j x^j$$
式中$x$是单变量输入，$w_0,w_1,\cdots,w_M$是$M+1$个参数。

选取平方损失为损失函数：

$$L(w)=\frac{1}{2}\sum\limits_{i=1}^{N}\bigg(\sum\limits_{j=0}^{M}w_j x_{i}^{j}-y_i\bigg)^2$$

对$w_j$求偏导并令其为$0$可得：
$$\frac{\partial L}{\partial w_j}=x_1^j (\sum\limits_{j=0}^{M}w_j x_1^j -y_1)+x_2^j (\sum\limits_{j=0}^{M}w_j x_2^j -y_2)+\cdots+x_N^j (\sum\limits_{j=0}^{M}w_j x_N^j -y_N)=0\Rightarrow \\\\
\sum\limits_{j=0}^{M}\sum\limits_{i=1}^{N}w_j x_i^j=\sum\limits_{i=1}^{N}x_i^j y_i$$

对于$j=0,1,\cdots,M$可得到如下线性方程组：
$$\begin{pmatrix}
  \sum\limits_{i=1}^{N}x_i^0 & \sum\limits_{i=1}^{N}x_i^1 & \cdots & \sum\limits_{i=1}^{N}x_i^M \\\\
  \sum\limits_{i=1}^{N}x_i^1 & \sum\limits_{i=1}^{N}x_i^2 & \cdots & \sum\limits_{i=1}^{N}x_i^{M+1} \\\\
  \vdots & \vdots & \ddots & \vdots \\\\
  \sum\limits_{i=1}^{N}x_i^M & \sum\limits_{i=1}^{N}x_i^{M+1} & \cdots & \sum\limits_{i=1}^{N}x_i^{M+M}
 \end{pmatrix}\begin{pmatrix}
   w_0\\\\
   w_1\\\\
   \vdots\\\\
   w_M
  \end{pmatrix}=\begin{pmatrix}
     \sum\limits_{i=1}^{N}x_i^0 y_i \\\\
    \sum\limits_{i=1}^{N}x_i^1 y_i \\\\
    \vdots \\\\
    \sum\limits_{i=1}^{N}x_i^M y_i
   \end{pmatrix}$$
求解上述方程组即可得到拟合多项式系数 $w_0^{\ast},w_1^{\ast},\cdots,w_M^{\ast} $.

python代码如下：

```python
import numpy as np
N = 5 #多项式的阶数

def getCoefficientMatrix(x,y):
    global N
    MeasureNumber = len(x)
    A = np.zeros((N+1,N+1))
    B = np.zeros(N+1)
    for i in range(N+1):
        for j in range(N+1):
            for k in range(MeasureNumber):
                A[i, j] += np.math.pow(x[k], i+j) #生成系数矩阵每个系数，可以改进为先求出0次到2(N+1)次方的和，然后一一填入系数矩阵
        for k in range(MeasureNumber):
            B[i] += np.math.pow(x[k], i)*y[k]
    return A, B

A, B = getCoefficientMatrix(x,y)
Omega = np.linalg.solve(A,B) #线性方程组求解，自己编程实现可以使用推荐使用共轭梯度

```

---
