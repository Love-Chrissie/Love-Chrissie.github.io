<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一笑懸命</title>
  
  <subtitle>Stay hungry. Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://love-chrissie.github.io/"/>
  <updated>2018-12-29T10:59:04.715Z</updated>
  <id>https://love-chrissie.github.io/</id>
  
  <author>
    <name>四月是你谎言</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二阶非齐次常系数线性微分方程解法</title>
    <link href="https://love-chrissie.github.io/2018/12/29/%E4%BA%8C%E9%98%B6%E9%9D%9E%E9%BD%90%E6%AC%A1%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E8%A7%A3%E6%B3%95/"/>
    <id>https://love-chrissie.github.io/2018/12/29/二阶非齐次常系数线性微分方程解法/</id>
    <published>2018-12-29T06:40:41.000Z</published>
    <updated>2018-12-29T10:59:04.715Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 18:59:13 GMT+0800 (CST) --><p>高数中在求解形如$y’’+py’+q=f(x)$的二阶常系数非齐次线性微分方程的时候，是分成各种情况，然后按照各种情况给出解的形式，高数书中都有讲到，这里不再赘述。可参考<a href="https://wenku.baidu.com/view/1ff60dd233d4b14e8524687a.html" target="_blank" rel="noopener">链接</a>。</p><p>这种机械记忆太困难了，然后我找找找就找到了求解该方程的一般方法——<a href="https://en.wikipedia.org/wiki/Variation_of_parameters" target="_blank" rel="noopener">常数变易法</a>。</p><p>常数变易法应该是个很熟悉的名词，在高数课本上推导一阶非齐次常系数线性微分方程的求解公式的时候就是用的该方法。在一般的高阶非齐次线性微分方程上，该方法同样适用。</p><h4 id="一阶非齐次线性微分方程"><a href="#一阶非齐次线性微分方程" class="headerlink" title="一阶非齐次线性微分方程"></a>一阶非齐次线性微分方程</h4><p>对于一阶齐次线性微分方程$y’ + p(x)y = 0$，可以直接通过分离变量，直接积分得到通解：</p><p>$$\begin{aligned}<br>\frac{dy}{dx} + p(x)y = 0&amp;\Rightarrow \frac{dy}{y}=-p(x)dx<br>\\&amp;\Rightarrow \ln |y| =\int-p(x)dx<br>\\&amp;\Rightarrow y = C_0 e^{\int-p(x)dx}<br>\end{aligned}$$</p><p>而求解一阶非齐次线性微分方程$y’ + p(x)y = q(x)$，我们知道非齐次线性微分方程的通解=齐次方程的通解+非齐次方程的一个特解，我们只需将齐次方程通解的常系数$C_0$改成关于$x$的函数$C(x)$来求解非齐次方程的一个特解。</p><p>设非齐次方程的一个特解为$y$，齐次方程的通解为$y_c$，非齐次方程的一个特解为$y_p$，有：</p><p>$$y=y_c+y_p,,\quad y_c = C_0 e^{\int-p(x)dx},\quad y_p=C(x)e^{\int-p(x)dx}$$</p><p>下面计算$C(x)$:</p><p>将$y_p=C(x)e^{\int-p(x)dx}$代入微分方程$y’ + p(x)y = q(x)$有:</p><p>$$\begin{align}<br>C ^ { \prime } &amp;( x ) e ^ { - \int p ( x ) d x } - C ( x ) p ( x ) e ^ { - \int p ( x ) d x } + p ( x ) C ( x ) e ^ { - \int p ( x ) d x } = q ( x )\\ \Rightarrow &amp;C ^ { \prime } ( x ) = e ^ { \int p ( x ) d x } q ( x )<br>\\ \Rightarrow &amp;C ( x ) = \int e ^ { \int p ( x ) d x } q ( x ) dx + C_1<br>\\<br>\end{align}$$</p><p>$$\therefore y=y_c+y_p= e ^ { - \int p ( x ) d x }\Big(C _ { 0 } + \int q ( x ) e ^ { \int p ( x ) d x } d x\Big)$$</p><h4 id="二阶非齐次线性微分方程"><a href="#二阶非齐次线性微分方程" class="headerlink" title="二阶非齐次线性微分方程"></a>二阶非齐次线性微分方程</h4><p>二阶齐次线性微分方程的通解形式为$y=C_1 u_1(x)+C_2 u_2(x)$，这里不赘述具体形式。和一阶非齐次方程求解一样的过程，我们使用常数变易法求二阶非齐次方程$y’’+p(x)y’+q(x)y=f(x)$的一个特解。</p><p>令$y_p=A(x) u_1(x)+B(x) u_2(x)$，注意到这里有两个未知量$A(x),B(x)$，需要两个方程才能求解出，注意到对于齐次方程$A(x),B(x)$均为常数，所以我们添加另一个条件为$0=A’(x) u_1(x)+B’(x) u_2(x)$。</p><p>将$y_p=A(x) u_1(x)+B(x) u_2(x)$代入微分方程有：</p><p>$$<br>\begin{align}y’&amp;=A’(x) u_1(x)+B’(x) u_2(x)+A(x) u_1’(x)+B(x)u_2’(x)<br>\\&amp;=A(x) u_1’(x)+B(x)u_2’(x)<br>\\y’’&amp;=A’(x) u_1’(x)+B’(x)u_2’(x)+A(x) u_1’’(x)+B(x)u_2’’(x)\end{align}<br>$$</p><p>$$\begin{align}\therefore y’’+py’+qy&amp;=A ( x ) (u _ { 1 }’’ +pu _ { 1 }’ +qu _ { 1 }) + B ( x ) (u _ { 2 }’’ +pu _ { 2 }’ +qu _ { 2 }) \\&amp;\quad+ A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )\\<br>&amp;=A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )\\&amp;=f(x)\end{align}$$</p><p>$\therefore$我们得到</p><p>$$<br>\begin{aligned}<br>A ^ { \prime } ( x ) u _ { 1 } ( x ) + B ^ { \prime } ( x ) u _ { 2 } (x)&amp;=0<br>\\A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )&amp;=f(x)<br>\end{aligned}<br>$$</p><p>解得：<br>$$A’(x)=-\frac{1}{W}u_2(x)f(x),\, B’(x)=\frac{1}{W}u_1(x)f(x)$$<br>即：<br>$$A(x)=\int_0^x-\frac{1}{W}u_2(t)f(t)dt+C_1,\, B(x)=\int_0^x\frac{1}{W}u_1(t)f(t)dt+C_2$$</p><p>其中$W$表示朗斯基行列式：</p><p>$$W(x)=\left|\begin{array}{cc}<br>u_1(x) &amp; u_2(x) \\<br>u_1’(x) &amp; u_2’(x)<br>\end{array}\right| $$</p><p>$$\therefore y=C_1 u_1(x)+C_2u_2(x)+\int_0^x\frac{u_1(t)u_2(x)-u_2(t)u_1(x)}{W}f(t)dt$$</p><h4 id="非齐次微分方程解的物理意义"><a href="#非齐次微分方程解的物理意义" class="headerlink" title="非齐次微分方程解的物理意义"></a>非齐次微分方程解的物理意义</h4><p><br>设某个线性系统满足线性微分方程$\frac{d^2 x}{dt^2}+w^2x=f$，比如受驱弹簧谐振子。第一项表示谐振子的加速度，第二项表示弹簧拉伸的张力，右项表示单位质量受作用的外力。</p><p>我们考虑某$\tau$时刻到$\tau+d \tau$时刻的情况，外力从$\tau$时刻开始作用到$\tau+d \tau$时刻结束。在这个极短的时间里，谐振子没有来得及产生位移，所以有：<br>$$x^{(\tau)}|_{t=\tau+d \tau}=0$$<br>而根据冲量定理有，单位质量谐振子动量的变化等于该时间间隔内外力的冲量，有:</p><p>$$<br>x_t^{(\tau)}|_{t=\tau+d \tau}-x_t^{(\tau)}|_{t=\tau}=f(\tau) d \tau<br>$$<br>注意到在$\tau $外力刚开始作用，没有使动量(速度)产生变化，所以$x_t^{(\tau)}|_{t=\tau}=0$,所以有：<br>$$<br>x_t^{(\tau)}|_{t=\tau+d \tau}=f(\tau) d \tau<br>$$</p><p>综上对于二阶非齐次线性系统$\frac{d^2 x}{dt^2}+w^2x=f$的求解，可以转化为求解齐次方程，满足：<br>$$\frac{d^2 x^{(\tau)}}{dt^2}+w^2x^{(\tau)}=0,\,x^{(\tau)}(\tau+d\tau)=0,\,\frac{dx^{(\tau)}}{dt}{\Bigg|}_{\tau+d\tau}=f(\tau)d\tau$$</p><p>记$x^{(\tau)}(t)=u(t,\tau)d\tau$,则:</p><p>$$x(t)=\int_0^t u(t,\tau)d\tau$$</p><p>其中$u(t,\tau)$满足：</p><p>$$\frac{d^2 u}{dt^2}+w^2u=0,\,u(\tau)=0,\,u’(\tau)=f(\tau)$$</p><p>该公式称为冲量定理。</p><blockquote><p>冲量定理在求解线性系统中有广泛应用，无论是常微分方程还是偏微分方程。</p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 18:59:13 GMT+0800 (CST) --&gt;&lt;p&gt;高数中在求解形如$y’’+py’+q=f(x)$的二阶常系数非齐次线性微分方程的时候，是分成各种情况，然后按照各种情况给出解的形式，高数书中都有讲到，这里
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="常微分方程" scheme="https://love-chrissie.github.io/tags/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
      <category term="数学物理方法" scheme="https://love-chrissie.github.io/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求解线性方程组的迭代法</title>
    <link href="https://love-chrissie.github.io/2018/11/06/%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>https://love-chrissie.github.io/2018/11/06/迭代法/</id>
    <published>2018-11-06T01:28:45.000Z</published>
    <updated>2018-12-31T11:38:34.915Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 31 2018 19:38:44 GMT+0800 (CST) --><h3 id="一般迭代法"><a href="#一般迭代法" class="headerlink" title="一般迭代法"></a>一般迭代法</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>对于一般的线性方程组直接求解有高斯消去法，对称矩阵的Cholesky分解，三对角矩阵的Thomas算法。而计算过程中经常会遇到稀疏矩阵（矩阵的零元素远多于非零元素），使用高斯消去会将零元素变为非零元素，增加不必要的计算次数。而迭代法是一种求解线性方程组系数矩阵为稀疏矩阵时的高效算法。</p><p>通过将线性方程组<br>$$\boldsymbol{Ax}=\boldsymbol{b}$$<br>等价改写成<br>$$\boldsymbol{x}=\boldsymbol{Bx}+\boldsymbol{f}$$<br>便可得到迭代法：<br>$$\boldsymbol{x}^{(k+1)}=\boldsymbol{B}\boldsymbol{x}^{(k)}+\boldsymbol{f}$$<br><strong>定理</strong>：迭代法<br>$$\boldsymbol{x}^{(k+1)}=\boldsymbol{B}\boldsymbol{x}^{(k)}+\boldsymbol{f}$$<br>对任意初始点$\boldsymbol{x}^{(0)}$和$\boldsymbol{f}$均收敛的充要条件是$\rho(\boldsymbol{B})&lt;1$.</p><h4 id="雅可比-Jacobi-迭代"><a href="#雅可比-Jacobi-迭代" class="headerlink" title="雅可比(Jacobi)迭代"></a>雅可比(Jacobi)迭代</h4><p>设一般形式的线性方程组如下：<br>$$<br>a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1,\\<br>a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\<br>\cdots\\<br>a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n<br>$$<br>将上述线性方程组作简单调整就可以得到Jacobi迭代公式了，将上述线性方程组写成如下形式：<br>$$\begin{align}<br>x_1&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2-\cdots-a_{1,n}x_n)，\\<br>x_2&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1-a_{2,3}x_3\cdots-a_{2,n}x_n),\\<br>\cdots\\<br>x_n&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1-a_{n,2}x_2-\cdots-a_{n,n-1}x_{n-1})<br>\end{align}<br>$$<br>上述线性方程组左边视为新一时刻的值，那么这个新值就可以利用右边的旧值计算得到，于是得到的迭代格式即：<br>$$<br>x_{i}^{(k+1)}=x_{i}^{(k)}+\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{n}a_{ij}x_{j}^{(k)}\Big)<br>$$<br>上式即为Jacobi迭代法。</p><p>设<br>$$\begin{align}\boldsymbol{D}&amp;=\boldsymbol{diag}(a_{11},a_{22},\cdots,a_{nn}),\\<br>\boldsymbol{L}&amp;=\begin{bmatrix}0 &amp; &amp; &amp; &amp; &amp;0\\<br>-a_{21} &amp; 0 &amp; &amp; &amp; &amp;\\<br>\vdots &amp; \ddots &amp; \ddots &amp; &amp; &amp;\\<br>-a_{j1} &amp; \cdots &amp; -a_{j,j-1} &amp; 0&amp; &amp;\\<br>\vdots &amp; &amp; \vdots &amp; \ddots &amp; \ddots &amp; \\<br>-a_{n1} &amp; \cdots &amp; -a_{n,j-1} &amp; \cdots &amp; -a_{n,n-1} &amp; 0<br>\end{bmatrix},\\<br>\boldsymbol{U}&amp;=\begin{bmatrix}0 &amp; -a_{12} &amp; \cdots &amp; -a_{1j} &amp; \cdots &amp; -a_{1n}\\<br>&amp; 0 &amp; \ddots &amp;\vdots &amp; &amp;\vdots\\<br>&amp; &amp; \ddots &amp; -a_{j-1,j} &amp; \cdots &amp; -a_{j-1,n}\\<br>&amp; &amp; &amp; \ddots &amp; \ddots &amp; \vdots\\<br>&amp; &amp; &amp; &amp; 0 &amp; -a_{n-1,n} \\<br>0 &amp; &amp; &amp; &amp; &amp; 0<br>\end{bmatrix},<br>\end{align}$$<br>则:<br>$$<br>\boldsymbol{A}=\boldsymbol{D}-\boldsymbol{L}-\boldsymbol{U}\\<br>\boldsymbol{D}\boldsymbol{x}=(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}+\boldsymbol{b}\\<br>\boldsymbol{x}=\boldsymbol{D}^{-1}(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}+\boldsymbol{D}^{-1}\boldsymbol{b}<br>$$<br>所以矩阵形式的Jacobi迭代即为:<br>$$<br>\boldsymbol{x}^{(k+1)}=\boldsymbol{D}^{-1}(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}^{(k)}+\boldsymbol{D}^{-1}\boldsymbol{b}<br>$$</p><h4 id="高斯塞德尔-Gauss–Seidel-迭代"><a href="#高斯塞德尔-Gauss–Seidel-迭代" class="headerlink" title="高斯塞德尔(Gauss–Seidel)迭代"></a>高斯塞德尔(Gauss–Seidel)迭代</h4><p>注意到Jacobi迭代计算每一个方程时都会产生新值，而这个新值就可以放到下一个方程里代替旧值计算，即原式：<br>$$\begin{align}<br>x_1^{(k+1)}&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2^{(k)}-\cdots-a_{1,n}x_n^{(k)})，\\<br>x_2^{(k+1)}&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1^{(k)}-a_{2,3}x_3^{(k)}\cdots-a_{2,n}x_n^{(k)}),\\<br>\cdots\\<br>x_n^{(k+1)}&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1^{(k)}-a_{n,2}x_2^{(k)}-\cdots-a_{n,n-1}x_{n-1}^{(k)})<br>\end{align}<br>$$<br>修改为：<br>$$\begin{align}<br>x_1^{(k+1)}&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2^{(k)}-\cdots-a_{1,n}x_n^{(k)})，\\<br>x_2^{(k+1)}&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1^{(k+1)}-a_{2,3}x_3^{(k)}\cdots-a_{2,n}x_n^{(k)}),\\<br>\cdots\\<br>x_{n-1}^{(k+1)}&amp;=\frac{1}{a_{n-1,n-1}}(b_{n-1}-a_{n-1,1}x_1^{(k+1)}-a_{n-1,2}x_2^{(k+1)}-\cdots-a_{n-1,n-2}x_{n-2}^{(k+1)}-a_{n-1,n}x_{n}^{(k)})\\<br>x_n^{(k+1)}&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1^{(k+1)}-a_{n,2}x_2^{(k+1)}-\cdots-a_{n,n-1}x_{n-1}^{(k+1)})<br>\end{align}<br>$$<br>即：<br>$$<br>x_{i}^{(k+1)}=\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$<br>写成矩阵形式:<br>$$<br>\begin{align}<br>\begin{pmatrix}a_{11} &amp; &amp; &amp;\\<br>&amp; a_{22} &amp; &amp; \\<br>&amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; a_{nn}\end{pmatrix}\begin{pmatrix}x_{1}^{(k+1)}\\<br>x_{2}^{(k+1)}\\<br>\vdots\\<br>x_{n}^{(k+1)}\end{pmatrix}&amp;=<br>\begin{pmatrix}<br>0 &amp; &amp; &amp;\\<br>-a_{21} &amp; 0 &amp; &amp; \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \\<br>-a_{n1} &amp; -a_{n2} &amp;\cdots &amp; 0\end{pmatrix}<br>\begin{pmatrix}<br>x_{1}^{(k+1)}\\<br>x_{2}^{(k+1)}\\<br>\vdots\\<br>x_{n}^{(k+1)}<br>\end{pmatrix}\\<br>&amp;+\begin{pmatrix}<br>0 &amp; -a_{12} &amp; &amp; -a_{1n}\\<br>&amp; 0 &amp; \cdots &amp; -a_{2n}\\<br>&amp; &amp; \ddots &amp; \vdots \\<br>&amp; &amp; &amp; 0\end{pmatrix}\begin{pmatrix}x_{1}^{(k)}\\<br>x_{2}^{(k)}\\<br>\vdots\\<br>x_{n}^{(k)}<br>\end{pmatrix}+<br>\begin{pmatrix}<br>b_1\\<br>b_2\\<br>\vdots\\<br>b_n<br>\end{pmatrix}<br>\end{align}$$</p><p>即：<br>$$<br>\boldsymbol{D}\boldsymbol{x}^{(k+1)}=\boldsymbol{L}\boldsymbol{x}^{(k+1)}+\boldsymbol{U}\boldsymbol{x}^{(k)}+\boldsymbol{b}\\<br>\boldsymbol{D}\boldsymbol{x}^{(k+1)}-\boldsymbol{L}\boldsymbol{x}^{(k+1)}=\boldsymbol{U}\boldsymbol{x}^{(k)}+\boldsymbol{b}\\<br>\boldsymbol{x}^{(k+1)}=(\boldsymbol{D}-\boldsymbol{L})^{-1}\boldsymbol{U}\boldsymbol{x}^{(k)}+(\boldsymbol{D}-\boldsymbol{L})^{-1}\boldsymbol{b}<br>$$</p><h4 id="连续过松弛-SOR"><a href="#连续过松弛-SOR" class="headerlink" title="连续过松弛(SOR)"></a>连续过松弛(SOR)</h4><p>高斯塞德尔迭代格式如下：</p><p>$$x_{i}^{(k+1)}=\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$</p><p></p><p>我们考虑上式右端和$x_i^{(k)}$的线性组合形式来计算$x_i^{(k+1)}$得到如下格式：</p><p>$$x_{i}^{(k+1)}=(1-\omega)x_{i}^{(k)}+\frac{\omega}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$</p><p>以上即为超松弛格式(SOR)，其中$\omega$为松弛系数，调整松弛系数来加快迭代计算速度，当$\omega=1$时，即为高斯塞德尔迭代。</p><p>代码见:</p><p><a href="https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/iterativeMethod.cpp" target="_blank" rel="noopener">https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/iterativeMethod.cpp</a></p><h3 id="一种特殊的迭代求解线性方程组的方法"><a href="#一种特殊的迭代求解线性方程组的方法" class="headerlink" title="一种特殊的迭代求解线性方程组的方法"></a>一种特殊的迭代求解线性方程组的方法</h3><p></p><h4 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h4><p>我们要求解的线性方程组为$Ax=b$，注意到函数$G(x)=\frac{1}{2}x^T Ax-x^T b$达到极小值时满足$\frac{d G}{dx}=Ax-b=0$，所以我们将求解线性方程组转换成求解函数$G(x)=\frac{1}{2}x^T Ax-x^T b$的极小值。为了保证解的唯一性，我们要求系数矩阵$A$是正定且对称的，这样函数$G(x)$为凸函数，其局部最小值即为全局极小值且唯一。</p><p>综上，我们可以使用一些求解函数最小值的算法求解线性方程组$Ax=b$，下面只介绍一种算法：共轭梯度法。</p><h4 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h4><p><strong>共轭</strong> 共轭可以理解成一种推广的向量正交，它指对于正定对称矩阵$A$，如果向量$u,v$满足$u^T Av=0$，则称向量$u,v$关于矩阵$A$共轭，显然向量$u,v$正交即向量$u,v$关于矩阵$I$共轭。</p><p>求解函数$G(x)$极小值过程为：</p><ol><li>选定初值$x_{0}$，初始搜索方向$s_{0}$，一般选为$s_{0}=-\nabla G(x_{0})$</li><li>下一步迭代点由式$x_{k+1}=x_{k}+\lambda_{k} s_{k}$给出，其中$\lambda_{k}$由$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$计算得到</li><li>计算下一步搜索方向$s_{k+1}$</li><li>重复上述过程直到满足收敛条件，如$\nabla G(x_k)=0$.</li></ol><p>上述中$\lambda_{k}$表示第$k$步沿方向$s_{k}$的搜索步长，$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$保证找到的步长使得函数减小最多。</p><p><strong>共轭梯度法</strong> 就是选定一组共轭的搜索方向，这种选取方式能保证迭代最多$n$步就能收敛最小值。</p><p><strong>首先</strong> 我们确定$\lambda_{k}$，$\lambda_{k}$由$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$确定。<br>所以：<br>$$\begin{align}\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}&amp;=\nabla G(x_{k}+\lambda_{k} s_{(k)})^T s_{k}\\<br>&amp;=[A(x_{k}+\lambda_{k} s_{k})]^T s_{k} -b^T s_{k}\\<br>&amp;=x_{k}^T As_{k}+\lambda_{k}s_{k}^T A s_{k}-b^T s_{k}\\<br>&amp;=0\\<br>\Longrightarrow \lambda_k&amp;= \frac{(b^T-x_k^T A)s_k}{s_k^T A s_k}=\frac{s_k^T( b-Ax_k)}{s_k^T A s_k}<br>\end{align}<br>$$</p><p><strong>然后</strong> 我们生成共轭方向作为每次迭代的搜索方向。我们可以将每次迭代计算得到的负梯度方向$=\nabla G(x)$作为初始方向，然后用类似<a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process" target="_blank" rel="noopener">施密特正交化</a>的方式生成共轭方向。</p><p>每次迭代计算的负梯度为：$-\nabla G(x_k)=b-Ax_k=r_k$，对于线性方程组$Ax=b$来说，$b-Ax_k$为每步计算的残差，所以这里设为$r_k$。</p><p>类似施密特正交化我们得到共轭方向：</p><p>$$\begin{align}s_0&amp;=r_0=b-Ax_0,\\<br>s_k&amp;=r_k-\sum_{i&lt;k}\frac{s_i^T A r_k}{s_i^T A s_i}s_i\end{align}$$</p><p>显然$s_j,\,(j=0,1,2…k)$相互关于$A$共轭，归纳显然。</p><p><strong>最后</strong> 证明共轭梯度法最多$n$步收敛</p><p>$n$步收敛只需要证明$\nabla G(x_n)=0$即可。</p><p>$$\begin{align}\nabla G(x_n)&amp;=Ax_n-b\\<br>&amp;=A(x_{n-1}+\lambda_{n-1}s_{n-1})-b\\<br>&amp;=\nabla G(x_{n-1})+\lambda_{n-1}As_{n-1}\\<br>&amp;=\nabla G(x_{j})+\sum\limits_{i=j}^{n-1}\lambda_i A s_i<br>\end{align}$$</p><p>对上式右乘$s_j,\, j=0,1,2,…,n-1$<br>$$\begin{align}\therefore \nabla G(x_n)^T s_j<br>&amp;=\nabla G(x_{j})^T s_j+\sum\limits_{i=j}^{n-1}\lambda_i s_i^T A s_j\\<br>&amp;=\nabla G(x_{j})^T s_j+\lambda_j s_j^T A s_j\\<br>&amp;=(\nabla G(x_{j})+\lambda_j A s_j)^Ts_j\\<br>&amp;=\nabla G(x_{j+1})^T s_j<br>\end{align}$$</p><p>注意到：</p><p>$$\frac{d G(x_j+\lambda s_j)}{d \lambda}=\nabla G(x_{j+1})^T s_j=0$$</p><p>有：</p><p>$$\nabla G(x_n)^T s_j=\nabla G(x_{j+1})^T s_j=0,\, j=0,1,2,…,n-1$$</p><p>对于一组$A$共轭向量$s_j,\, j=0,1,2,…,n-1$,$\nabla G(x_n)^T s_j=0$,显然$\nabla G(x_n)=0$,所以共轭梯度法最多$n$步收敛。</p><p><strong>程序计算步骤</strong>：</p><p>$$\begin{align} &amp;r_0 = b - Ax_0\\<br>&amp;\text{如果} r_0\text{足够小, 就返回 } x_0\text{ 作为结果}\\<br>&amp;s_0=r_0\\<br>&amp;k=0\\<br>&amp;\text{循环：}\\<br>&amp;\qquad \alpha_k=\frac {r_k^T r_k}{s_k^T As_k}\\<br>&amp;\qquad x_{k+1}= x_k+\alpha_k s_k\\<br>&amp;\qquad r_{k+1}= r_k-\alpha_k As_k\\<br>&amp;\qquad \text{如果} r_{k+1}\text{ 足够小, 就跳出循环}\\<br>&amp;\qquad \beta_k={\frac { r_{k+1}^T r_{k+1}}{ r_k^T r_k}}\\<br>&amp;\qquad s_{k+1} = r_{k+1}+\beta_k s_k\\<br>&amp;\qquad k=k+1\\<br>&amp;\text{返回 } x_{k+1}\text{作为结果}<br>\end{align}$$</p><p>代码见:</p><p><a href="https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/ConjugateGradient.py" target="_blank" rel="noopener">https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/ConjugateGradient.py</a></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 31 2018 19:38:44 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;一般迭代法&quot;&gt;&lt;a href=&quot;#一般迭代法&quot; class=&quot;headerlink&quot; title=&quot;一般迭代法&quot;&gt;&lt;/a&gt;一般迭代法&lt;/h3&gt;&lt;h
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="矩阵与数值分析" scheme="https://love-chrissie.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>QR分解之Householder变换</title>
    <link href="https://love-chrissie.github.io/2018/10/19/QR%E5%88%86%E8%A7%A3%E4%B9%8BHouseholder%E5%8F%98%E6%8D%A2/"/>
    <id>https://love-chrissie.github.io/2018/10/19/QR分解之Householder变换/</id>
    <published>2018-10-19T12:25:24.000Z</published>
    <updated>2018-11-21T11:49:07.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>定义Householder矩阵如下：<br>$$\boldsymbol{H}(\boldsymbol{w})=\boldsymbol{I}-\frac{2}{\boldsymbol{w}^T \boldsymbol{w}} \boldsymbol{w} \boldsymbol{w}^T$$<br>显然该矩阵具有如下性质：</p><ol><li>$\boldsymbol{H}^T=\boldsymbol{H}$，即$\boldsymbol{H}$为对称阵；</li><li>$\boldsymbol{H}^T\boldsymbol{H}=\boldsymbol{I}$，即$\boldsymbol{H}$为正交阵；</li><li>如果$\boldsymbol{H}\boldsymbol{x}=\boldsymbol{y}$，则$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$；反之，对于任意两个向量$\boldsymbol{x},\boldsymbol{y}\in \mathbb{R}^n$，若$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$，且$\vec{x}\neq\vec{y}$，则必存在Householder矩阵$\boldsymbol{H}$，使得$\boldsymbol{y}=\boldsymbol{H}\boldsymbol{x}$；</li><li>设$\vec{x}=(x_1,x_2,\cdots,x_n)^T\in \mathbb{R}^n$且$\vec{x}\neq\vec{0}$，取$\vec{w}=\vec{x}\pm\parallel \vec{x}\parallel_2 \vec{e}_1$，则$\boldsymbol{H}(\boldsymbol{w})\boldsymbol{x}=\boldsymbol{H}(\boldsymbol{x}\pm\parallel \boldsymbol{x}\parallel_2 \boldsymbol{e}_1)\vec{x}=\pm\parallel \vec{x}\parallel_2 \vec{e}_1=\pm\parallel \vec{x}\parallel_2 (1,0,\cdots,0)^T$.</li></ol><p>证明：(1),(2)显然，证明(3)显然有：<br>$$\parallel \boldsymbol{y}\parallel_2^2=\boldsymbol{y}^T\boldsymbol{y}=(\boldsymbol{H}\boldsymbol{x})^T(\boldsymbol{H}\boldsymbol{x})=\boldsymbol{x}^T(\boldsymbol{H}^T\boldsymbol{H})\boldsymbol{x}=\boldsymbol{x}^T\boldsymbol{x}=\parallel\boldsymbol{x}\parallel_2^2$$<br>反之，若$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$，且$\vec{x}\neq\vec{y}$,令$\boldsymbol{w}=\boldsymbol{x}-\boldsymbol{y}$,有：<br>$$\parallel\boldsymbol{w}\parallel_2^2=(\boldsymbol{x}-\boldsymbol{y})^T(\boldsymbol{x}-\boldsymbol{y})=(2\boldsymbol{x}-(\boldsymbol{x}+\boldsymbol{y}))^T(\boldsymbol{x}-\boldsymbol{y})=2\boldsymbol{x}^T(\boldsymbol{x}-\boldsymbol{y})$$</p><p>$$\begin{align}\boldsymbol{H}(\boldsymbol{w})\boldsymbol{x}&amp;=(\boldsymbol{I}-\frac{2}{\boldsymbol{w}^T \boldsymbol{w}} \boldsymbol{w} \boldsymbol{w}^T)\boldsymbol{x}=(\boldsymbol{I}-\frac{2}{\parallel\boldsymbol{x}-\boldsymbol{y}\parallel_2^2} (\boldsymbol{x}-\boldsymbol{y}) (\boldsymbol{x}-\boldsymbol{y})^T)\boldsymbol{x}\\<br>&amp;=\boldsymbol{x}-\frac{2(\boldsymbol{x}-\boldsymbol{y})^T\boldsymbol{x}}{\parallel\boldsymbol{x}-\boldsymbol{y}\parallel_2^2}(\boldsymbol{x}-\boldsymbol{y})=\boldsymbol{x}-(\boldsymbol{x}-\boldsymbol{y})=\boldsymbol{y}\end{align}$$</p><p>性质(4)由性质(3)自然得出。</p><p>$m\times n$阶矩阵三角化过程<br>记<br>$$<br>A_{m\times n}^{(1)}=A_{m\times n}=\begin{bmatrix}a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\\a_{21}^{(1)} &amp; a_{22}^{(1)} &amp; \cdots &amp; a_{2n}^{(1)}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\a_{m1}^{(1)} &amp; a_{m2}^{(1)} &amp; \cdots &amp; a_{mn}^{(1)}\end{bmatrix}$$</p><p>取正交矩阵$Q_1=H_1$(依性质4取Householder矩阵)，这里$H_1$是将$m$维向量$(a_{11}^{(1)}, a_{21}^{(1)},\cdots,a_{m1}^{(1)})^T$变换为$m$维向量$(k_1, 0,\cdots,0)^T$的Householder变换矩阵</p><p>$$H_1=I_m-\alpha_1 \boldsymbol{u}_1 \boldsymbol{u}_1^T$$<br>这里<br>$$|k_1|^2=\boldsymbol{x}^T \boldsymbol{x},\boldsymbol{u}=\boldsymbol{x-k_1\boldsymbol{e}_1},\alpha=\frac{1}{k_1(k_1-\boldsymbol{e}_1^T \boldsymbol{x})}=\frac{2}{\boldsymbol{u}^T\boldsymbol{u}}$$</p><p>得到<br>$$A_{m\times n}^{(2)}=Q_1 A_{m\times n}^{(1)}=\begin{bmatrix}k_1 &amp; a_{12}^{(2)} &amp; \cdots &amp; a_{1n}^{(2)}\\0 &amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; a_{m2}^{(2)} &amp; \cdots &amp; a_{mn}^{(2)}\end{bmatrix}$$</p><p>这里<br>$$<br>\begin{bmatrix}a_{1,j}^{(2)}\\a_{2,j}^{(2)}\\ \vdots \\ a_{m,j}^{(2)}\end{bmatrix}=H_1\begin{bmatrix}a_{1,j}^{(1)}\\a_{2,j}^{(1)}\\ \vdots \\ a_{mj}^{(1)}\end{bmatrix}=\begin{bmatrix}a_{1,j}^{(1)}\\a_{2,j}^{(1)}\\ \vdots \\ a_{mj}^{(1)}\end{bmatrix}-\alpha_1\sum\limits_{l=1}^{m}u_{1l}a_{l,j}^{(1)}\boldsymbol{u}_1\quad\,j=2,3,\cdots,n$$</p><p>一般第$k$步取正交矩阵$Q_k$<br>$$Q_k=\begin{bmatrix}I_{k-1} &amp; \quad \\ \quad &amp; H_k\end{bmatrix}$$<br>这里$H_k$是将$m-k+1$维向量$(a_{k,k}^{(k)},a_{k+1,k}^{(k)},\cdots,a_{m,k}^{(k)})^T$变换为$m-k+1$维向量$(k_k,0,\cdots,0)^T$的Householder矩阵</p><p>$$H_k=I_{m-k+1}-\alpha_k \boldsymbol{u}_k \boldsymbol{u}_k^T$$</p><p>这里$\boldsymbol{u}_k$为$m-k+1$维向量，这时</p><p>$$A_{m\times n}^{(k+1)}=Q_1 A_{m\times n}^{(k)}=\begin{bmatrix}k_1 &amp; a_{1,2}^{(2)} &amp; \cdots &amp; a_{1,k}^{(2)} &amp; a_{1,k+1}^{(2)} &amp; \cdots &amp; a_{1,n}^{(2)}\\ &amp; k_2 &amp; \cdots &amp; a_{2,k}^{(3)} &amp; a_{2,k+1}^{(3)} &amp; \cdots &amp; a_{2,n}^{(3)}\\<br>&amp; &amp; \ddots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots\\ &amp; &amp; &amp; k_k &amp; a_{k,k+1}^{(k+1)} &amp; \cdots &amp; a_{k,n}^{(k+1)}\\&amp; &amp; &amp; &amp; a_{k+1,k+1}^{(k+1)} &amp; \cdots &amp; a_{k+1,n}^{(k+1)}\\&amp; &amp; &amp; &amp; \cdots &amp; \cdots &amp; \cdots\\&amp; &amp; &amp; &amp; a_{m,k+1}^{(k+1)} &amp; \cdots &amp; a_{m,n}^{(k+1)} \end{bmatrix}$$</p><p>其中<br>$$<br>\begin{bmatrix}a_{k,j}^{(k+1)}\\a_{k+1,j}^{(k+1)}\\ \vdots \\ a_{m,j}^{(k+1)}\end{bmatrix}=H_k\begin{bmatrix}a_{k,j}^{(k)}\\a_{k+1,j}^{(k)}\\ \vdots \\ a_{mj}^{(k)}\end{bmatrix}=\begin{bmatrix}a_{k,j}^{(k)}\\a_{k+1,j}^{(k)}\\ \vdots \\ a_{mj}^{(k)}\end{bmatrix}-\alpha_k\sum\limits_{l=1}^{m-k+1}u_{kl}a_{k+l-1,j}^{(k)}\boldsymbol{u}_k\quad\,j=k+1,\cdots,n,\text{其他元素不变}$$</p><p>记$s=\min(m-1,n)$则当$k=s$时即可完成矩阵的三角化过程，即<br>$$QA=Q_s Q_{s-1} \cdots Q_1 A=R$$<br>由于$Q$为正交矩阵，所以<br>$$A=Q^T R$$</p><p>$QR$分解的python代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">householder</span><span class="params">(A, y)</span>:</span></span><br><span class="line">    row = np.shape(A)[<span class="number">0</span>]</span><br><span class="line">    col = np.shape(A)[<span class="number">1</span>]</span><br><span class="line">    u = np.zeros(row)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(col):</span><br><span class="line">        <span class="comment"># 计算第i列模</span></span><br><span class="line">        aa = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(i, row):</span><br><span class="line">            aa += A[l, i]*A[l, i]</span><br><span class="line">        aa = np.sqrt(aa)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 防止分母过小</span></span><br><span class="line">        <span class="keyword">if</span> A[i, i] &gt; <span class="number">0.0</span> :</span><br><span class="line">            ki = -aa</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ki = aa</span><br><span class="line">        alpha = <span class="number">1.0</span>/(ki*(ki-A[i, i]))</span><br><span class="line">        u[i] = A[i, i] - ki</span><br><span class="line">        A[i, i] = ki</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(i+<span class="number">1</span>, row):</span><br><span class="line">            u[l] = A[l, i]</span><br><span class="line">            A[l, i] = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, col):</span><br><span class="line">            aa = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(i, row):</span><br><span class="line">                aa += u[l] * A[l, j]</span><br><span class="line">            aa = alpha * aa</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(i, row):</span><br><span class="line">                A[l, j] -= aa * u[l]</span><br><span class="line">        aa = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(i, row):</span><br><span class="line">            aa += u[l] * y[l]</span><br><span class="line">        aa *= alpha</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(i, row):</span><br><span class="line">            y[l] -= aa * u[l]</span><br><span class="line">    print(<span class="string">"Matrix HA, and Hy:"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">            print(<span class="string">"&#123;:14.8f&#125;"</span>.format(A[i, j]), end=<span class="string">''</span>)</span><br><span class="line">        print(<span class="string">"  |&#123;:14.8f&#125;"</span>.format(y[i]))</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;定义Householder矩阵如下：&lt;br&gt;$$\boldsymbol{H}(\boldsymbol{w})=\boldsymbol{I}-\frac{2}
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="矩阵与数值分析" scheme="https://love-chrissie.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>一道三角函数无穷积分两道数论</title>
    <link href="https://love-chrissie.github.io/2018/10/15/%E4%B8%80%E9%81%93%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E6%97%A0%E7%A9%B7%E7%A7%AF%E5%88%86/"/>
    <id>https://love-chrissie.github.io/2018/10/15/一道三角函数无穷积分/</id>
    <published>2018-10-15T12:48:10.000Z</published>
    <updated>2018-11-21T11:54:41.821Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>证明：$\int_{0}^{\infty}\cos{x^p}dx=\frac{\Gamma(\frac{1}{p})\cos {\frac{\pi}{2p}}}{p}$</p><p>过程：<br>$$\begin{align}\int_{0}^{\infty}\cos{x^p}dx &amp;=\frac{1}{p}\int_{0}^{\infty}\frac{\cos u}{u^{1-\frac{1}{u}}}du=\frac{1}{p}\int_0^{\infty}z^{-\frac{1}{p}}e^{-zu}dz\,\cdot\int_0^{\infty}\cos udu\\<br>&amp;=\frac{1}{p\Gamma(1-\frac{1}{p})}\int_0^{\infty}z^{-\frac{1}{p}}dz\int_0^{\infty}\cos u e^{-zu}du\\<br>&amp;=\frac{1}{p\Gamma(1-\frac{1}{p})}\int_0^{\infty}\frac{z^{1-\frac{1}{p}}}{z^2+1}dz,\quad\text{let }t=z^2\\<br>&amp;=\frac{1}{2p\Gamma(1-\frac{1}{p})}\int_0^{\infty}\frac{t^{-\frac{1}{2p}}}{t+1}dt=\frac{1}{2p\Gamma(1-\frac{1}{p})}B(1-\frac{1}{2p},\,\frac{1}{2p})\\<br>&amp;=\frac{\sin\big[(1-\frac{1}{p})\pi\big]\Gamma(\frac{1}{p})}{2p\pi}\cdot\frac{\pi}{\sin\big[(1-\frac{1}{2p})\pi\big]}\\<br>&amp;=\frac{\Gamma(\frac{1}{p})\cos {\frac{\pi}{2p}}}{p}\end{align}$$</p><p>其中利用到了:</p><p>$$<br>\Gamma(x) = \int_0^{\infty}t^{x-1}e^{-t}dt,\\<br>\frac{1}{x^s}=\frac{1}{\Gamma(s)}\int_0^{\infty}z^{s-1}e^{-xz}dz,\\<br>\text{余元公式:}\,\Gamma(x)\Gamma(1-x)=\frac{\pi}{\sin{\pi x}},\\<br>\beta \text{函数与}\Gamma\text{函数关系：}\, B(x, y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}<br>$$</p><h4 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h4><ol><li>证明$1+\frac{1}{2}+\cdots+\frac{1}{n}$不是整数，其中$n$为大于1的整数。</li><li>若素数$p\equiv 3(\, mod\,4\,)$,那么素数$p$不能表示成两整数的平方和。</li></ol><p>证明：</p><p>1:$\text{设}1+\frac{1}{2}+\cdots+\frac{1}{n}=k$为整数，两边乘以$n$的阶乘那么$n!+\frac{n!}{2}+\cdots+\frac{n!}{n}=kn!$.设$p$是小于$n$的最大素数，那么右边$kn!$能被$p$整除，而左边$n!+\frac{n!}{2}+\cdots+\frac{n!}{p}+\cdots+\frac{n!}{n}$的每一项，很明显除了$\frac{n!}{p}$不能被$p$整除外，都能被$p$整除，所以左边不能被$p$整除。矛盾，故$1+\frac{1}{2}+\cdots+\frac{1}{n}$不是整数。</p><p>2:由于$p$是素数，且两个奇数平方相加为偶数，两偶数平方相加为也为偶数，所以必然有$p=(2n)^2+(2n+1)^2$,那么$p \equiv (2n)^2+(2n+1)^2 \equiv 1(mod 4)$，矛盾，故素数$p$不能表示成两整数的平方和。</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h4 id=&quot;积分&quot;&gt;&lt;a href=&quot;#积分&quot; class=&quot;headerlink&quot; title=&quot;积分&quot;&gt;&lt;/a&gt;积分&lt;/h4&gt;&lt;p&gt;证明：$\int_{0
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="无穷积分" scheme="https://love-chrissie.github.io/tags/%E6%97%A0%E7%A9%B7%E7%A7%AF%E5%88%86/"/>
    
      <category term="数论" scheme="https://love-chrissie.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>正定矩阵的cholesky分解</title>
    <link href="https://love-chrissie.github.io/2018/10/12/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E7%9A%84cholesky%E5%88%86%E8%A7%A3/"/>
    <id>https://love-chrissie.github.io/2018/10/12/正定矩阵的cholesky分解/</id>
    <published>2018-10-12T02:27:00.000Z</published>
    <updated>2018-11-21T11:48:02.138Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="正定矩阵的cholesky分解"><a href="#正定矩阵的cholesky分解" class="headerlink" title="正定矩阵的cholesky分解"></a>正定矩阵的cholesky分解</h3><p>由于正定矩阵的主子式均大于零，可得正定矩阵的顺序主子式均大于零，所以正定矩阵$\boldsymbol A$有唯一的$\boldsymbol{LDU}$分解，即：<br>$$<br>\boldsymbol A = \boldsymbol{LDU}$$<br>这里$\boldsymbol L$为单位下三角矩阵，$\boldsymbol U$为单位上三角矩阵，$\boldsymbol D$为对角矩阵。又$\boldsymbol A$是对称矩阵，故：<br>$$<br>\boldsymbol A = \boldsymbol A^T=(\boldsymbol{LDU})^T=\boldsymbol U^T \boldsymbol D \boldsymbol L^T$$</p><p>根据$\boldsymbol{LDU}$分解的唯一性得<br>$$<br>\boldsymbol U=\boldsymbol L^T$$<br>故正定矩阵$\boldsymbol A$有分解式<br>$$\boldsymbol A = \boldsymbol L \boldsymbol D \boldsymbol L^T$$<br>这里$\boldsymbol L$的对角元素皆为1.记<br>$$\boldsymbol D = diag(d_1,d_2,\cdots,d_n)$$<br>由$\boldsymbol A$的正定性可得<br>$$d_i&gt;0,i=1,2,\cdots,n$$<br>若记<br>$$D^{\frac{1}{2}}=diag(\sqrt{d_1},\sqrt{d_2},\cdots,\sqrt{d_n})$$<br>则<br>$$\boldsymbol A = \boldsymbol L\boldsymbol D^{\frac{1}{2}}\boldsymbol D^{\frac{1}{2}}\boldsymbol L^T=(\boldsymbol L\boldsymbol D^{\frac{1}{2}})(\boldsymbol L\boldsymbol D^{\frac{1}{2}})^T=\widetilde{\boldsymbol L} \widetilde{\boldsymbol L}^T$$<br>这里$\widetilde{\boldsymbol L}=\boldsymbol L \boldsymbol D^{\frac{1}{2}}$是下三角矩阵，其对角元素皆为正数，则这种分解也是唯一的。称之为正定矩阵的Cholesky分解。</p><h4 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h4><p>由<br>$$\boldsymbol A = \begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{pmatrix}=\begin{pmatrix}l_{11} &amp; &amp; &amp; \\<br>l_{21} &amp; l_{22} &amp; &amp; \\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \\\<br>l_{n1} &amp; l_{n2} &amp; \cdots &amp; l_{nn}\end{pmatrix}\begin{pmatrix}l_{11} &amp; l_{21} &amp; \cdots &amp; l_{n1}\\<br>&amp; l_{22} &amp; \cdots &amp; l_{n2}\\\<br>&amp; &amp; \ddots &amp; \vdots \\\<br>&amp; &amp; &amp; l_{nn}\end{pmatrix}=\boldsymbol L \boldsymbol L^T$$</p><p>矩阵对应每项相等可以得到矩阵$\boldsymbol L$的各项计算公式：<br>$$<br>a_{ik}=\sum\limits_{s=1}^{k-1}l_{is}l_{ks}+l_{kk}^2$$<br>所以：<br>$$l_{kk}=\sqrt{a_{kk}-\sum\limits_{s=1}^{k-1}l_{ks}^2}\\<br>l_{ik}=\frac{a_{ik}-\sum\limits_{s=1}^{k-1}l_{is}l_{ks}}{l_{kk}},\quad i=k+1,\cdots,n$$</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chollt</span><span class="params">(A)</span>:</span></span><br><span class="line">    EPSILON = <span class="number">1e-8</span></span><br><span class="line">    DIM = len(A)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(DIM):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, DIM):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">                A[i, k] = A[i, k] - A[i, j] * A[k, j]</span><br><span class="line">        <span class="keyword">if</span> np.fabs(A[k, k]) &lt; EPSILON:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        A[k, k] = np.math.sqrt(A[k, k])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>, DIM):</span><br><span class="line">            A[i, k] = A[i, k] / A[k, k]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;正定矩阵的cholesky分解&quot;&gt;&lt;a href=&quot;#正定矩阵的cholesky分解&quot; class=&quot;headerlink&quot; title=&quot;正定矩
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="矩阵与数值分析" scheme="https://love-chrissie.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>一维稳态流动与扩散问题验证</title>
    <link href="https://love-chrissie.github.io/2018/10/10/%E4%B8%80%E7%BB%B4%E7%A8%B3%E6%80%81%E6%B5%81%E5%8A%A8%E4%B8%8E%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98%E9%AA%8C%E8%AF%81/"/>
    <id>https://love-chrissie.github.io/2018/10/10/一维稳态流动与扩散问题验证/</id>
    <published>2018-10-10T14:22:14.000Z</published>
    <updated>2018-10-15T15:11:34.535Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="控制一维稳态流动与扩散问题验证"><a href="#控制一维稳态流动与扩散问题验证" class="headerlink" title="控制一维稳态流动与扩散问题验证"></a>控制一维稳态流动与扩散问题验证</h3><p>考虑一段长为1m的区域，其稳态无源项的对流扩散方程如下：<br>$$\dfrac{d}{dx}(\rho u\phi)=\dfrac{d}{dx}(\Gamma\dfrac{d\phi}{dx})$$<br>流动还需满足连续性方程：<br>$$\dfrac{d(\rho u)}{dx}$$<br><img src="/images/WX20181010-205935@2x.png" alt=""><br>积分上两式可得：<br>$$(\rho u A\phi)_e-(\rho u A\phi)_w=\big(\Gamma A\dfrac{d\phi}{dx}\big)_e-\big(\Gamma A\dfrac{d\phi}{dx}\big)_w\\<br>(\rho u)_e-(\rho u)_w=0$$<br>定义两变量</p><ul><li>$F=\rho u$ 表示单位面积对流通量</li><li>$D=\frac{\Gamma}{\delta x}$ 表示通过单元面的扩导</li></ul><p>所以积分的对流扩散方程可重新写为：<br>$F_w=(\rho u)_w,D_w=\frac{\Gamma_w}{\delta x_{WP}},F_e=(\rho u)_e,D_e=\frac{\Gamma_e}{\delta x_{PE}}.$</p><p>连续性方程为:<br>$F_e-F_w=0$</p><p>使用中心差分离散方程最后的形式为：<br>$$a_P \phi_P=a_W \phi_W+a_E \phi_E,\text{其中}a_W=D_w+\frac{F_w}{2},a_E=D_e-\frac{F_e}{2},a_P=a_E+a_W+(F_e-F_w)$$</p><p>本次算例解析解为：<br>$$\frac{\phi-\phi_0}{\phi_L-\phi_0}=\frac{\exp(\frac{\rho ux}{\Gamma})-1}{\exp(\frac{\rho uL}{\Gamma})-1}$$</p><p>边界条件为：$\phi_0=1$当$x=0$和$\phi_L=0$当$x=L$.<br>对边界点，其离散方程应改为：</p><ul><li>对于第一个点，$-(a_P+a_W) \phi_P+a_E\phi_E+2a_W\phi_0=0 $</li><li>对于最后一个点，$a_W \phi_W-(a_P+a_E) \phi_P=0 $</li></ul><p>三种情况验证：</p><ol><li>u=0.1 m/s,节点数为5</li><li>u=2.5 m/s,节点数为5</li><li>u=2.5 m/s,节点数为20</li></ol><p>得到三种图像如下：<br><img src="/images/case1.png" alt="case1"><br><img src="/images/case2.png" alt="case2"><br><img src="/images/case3.png" alt="case3"></p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python  </span></span><br><span class="line"><span class="comment"># encoding: utf-8  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">u = <span class="number">2.5</span> <span class="comment"># 流速</span></span><br><span class="line">n=<span class="number">20</span> <span class="comment"># 划分节点数（或者说控制体个数）</span></span><br><span class="line">L = <span class="number">1.0</span> <span class="comment"># 总长度</span></span><br><span class="line">rho = <span class="number">1.0</span> <span class="comment"># 密度</span></span><br><span class="line">Gamma = <span class="number">0.1</span> <span class="comment"># 扩散系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解析解</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">phi = np.array([(np.exp(rho*u*L/Gamma)-np.exp(rho*u*xx/Gamma))/(np.exp(rho*u*L/Gamma)<span class="number">-1</span>) <span class="keyword">for</span> xx <span class="keyword">in</span> x])</span><br><span class="line"></span><br><span class="line"><span class="comment">#数值解</span></span><br><span class="line">delta_x = L/n <span class="comment"># 控制体边长</span></span><br><span class="line">F = rho*u <span class="comment"># 对流通量</span></span><br><span class="line">D = Gamma/delta_x <span class="comment"># 扩导</span></span><br><span class="line">aW=D+F/<span class="number">2</span></span><br><span class="line">aE=D-F/<span class="number">2</span></span><br><span class="line">aP=aW+aE</span><br><span class="line">A = -aP*np.ones(n)</span><br><span class="line">B = np.zeros(n)</span><br><span class="line">B[<span class="number">0</span>] = <span class="number">-2</span>*aW</span><br><span class="line">A[<span class="number">0</span>] = A[<span class="number">0</span>]-aW</span><br><span class="line">A[n<span class="number">-1</span>] = A[n<span class="number">-1</span>]-aE</span><br><span class="line"><span class="comment">#Thomas算法，并同时画图</span></span><br><span class="line"><span class="comment">#计算过程使用托马斯算法，这里由于生成的三对阵简答，没有使用通用的thomas算法，而是针对本算例进行了简化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    A[i] = A[i]-aW*aE/A[i<span class="number">-1</span>]</span><br><span class="line">    B[i] = B[i]-aW*B[i<span class="number">-1</span>]/A[i<span class="number">-1</span>]</span><br><span class="line">B[n<span class="number">-1</span>] = B[n<span class="number">-1</span>]/A[n<span class="number">-1</span>]</span><br><span class="line">xx = np.linspace(delta_x/<span class="number">2</span>,<span class="number">1</span>-delta_x/<span class="number">2</span>,n)</span><br><span class="line">plt.scatter(xx[n<span class="number">-1</span>], B[n<span class="number">-1</span>], color=<span class="string">''</span>, marker=<span class="string">'o'</span>, edgecolors=<span class="string">'g'</span>, s=<span class="number">100</span>, label=<span class="string">'numerical solution'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    B[i] = (B[i]-aE*B[i+<span class="number">1</span>])/A[i]</span><br><span class="line">    plt.scatter(xx[i], B[i], color=<span class="string">''</span>, marker=<span class="string">'o'</span>, edgecolors=<span class="string">'g'</span>, s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">0</span>, <span class="number">1</span>, color=<span class="string">''</span>, marker=<span class="string">'o'</span>, edgecolors=<span class="string">'g'</span>, s=<span class="number">100</span>) <span class="comment"># 边界点</span></span><br><span class="line">plt.scatter(<span class="number">1</span>, <span class="number">0</span>, color=<span class="string">''</span>, marker=<span class="string">'o'</span>, edgecolors=<span class="string">'g'</span>, s=<span class="number">100</span>) <span class="comment"># 边界点</span></span><br><span class="line">plt.plot(x,phi,label=<span class="string">'analysis solution'</span>)</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]</span><br><span class="line">plt.xlabel(<span class="string">u"位置"</span>) <span class="comment"># x轴名称</span></span><br><span class="line">plt.ylabel(<span class="string">u"变量"</span>) <span class="comment"># y轴名称</span></span><br><span class="line">plt.title(<span class="string">u"一维稳态对流扩散问题"</span>) <span class="comment"># 图名</span></span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment">#plt.text() # 在图上自定位置处写下标记</span></span><br><span class="line"><span class="comment">#plt.axis([0,L,0,1]) # 设定坐标轴范围</span></span><br><span class="line">plt.grid(<span class="keyword">True</span>) <span class="comment"># 开关网格</span></span><br><span class="line">plt.savefig(<span class="string">"case3.png"</span>)</span><br><span class="line">plt.show() <span class="comment"># 打印图像</span></span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;控制一维稳态流动与扩散问题验证&quot;&gt;&lt;a href=&quot;#控制一维稳态流动与扩散问题验证&quot; class=&quot;headerlink&quot; title=&quot;控制一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fibonacci序列</title>
    <link href="https://love-chrissie.github.io/2018/10/10/Fibonacci%E5%BA%8F%E5%88%97/"/>
    <id>https://love-chrissie.github.io/2018/10/10/Fibonacci序列/</id>
    <published>2018-10-10T06:19:21.000Z</published>
    <updated>2018-10-10T13:49:37.271Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="从Fibonacci序列谈起"><a href="#从Fibonacci序列谈起" class="headerlink" title="从Fibonacci序列谈起"></a>从Fibonacci序列谈起</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>$F_0=0,\quad F_1=1,\quad F_n=F_{n-1}+F_{n-2}\quad (n&gt;1)$</p><p>递归算法的$F_n$计算时间复杂度为$O(2^n)$，为指数时间。空间复杂度为$S_n=O(n)$为线性空间。</p><p>改用备忘录的方式计算Fibonacci序列可以更节约时间。类似如下方式：</p><table><thead><tr><th style="text-align:center">$F_0$</th><th style="text-align:center">$F_1$</th><th style="text-align:center">$F_2$</th><th style="text-align:center">$F_3$</th><th style="text-align:center">$F_4$</th><th style="text-align:center">$F_5$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">5</td></tr></tbody></table><p>但空间仍然是$O(n)$，如果只需要求$F_n$则有很大空间浪费。所以我们只需要保存前两项即可。<br>$P_1=0,P_2=1,C=P_1+P_2=1$,下一次赋值结果为$P_1=1,P_2=1,C=2$,时间复杂度为$O(n)$,空间复杂度为$O(1)$。</p><p>更好的方式：<br>使用Fibonacci序列的矩阵形式<br>$$\begin{align}\begin{pmatrix}<br>F_{n+1}\\<br>F_n<br>\end{pmatrix}&amp;=\begin{pmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}<br>\begin{pmatrix}<br>F_{n}\\<br>F_{n-1}<br>\end{pmatrix}\\&amp;=\begin{pmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}^2<br>\begin{pmatrix}<br>F_{n-1}\\<br>F_{n-2}<br>\end{pmatrix}\\&amp;\cdots\\<br>&amp;=\begin{pmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}^n<br>\begin{pmatrix}<br>F_{1}\\<br>F_{0}<br>\end{pmatrix}<br>\end{align}<br>$$</p><p>即最后结果为：<br>$$\begin{pmatrix}<br>F_{n+1}\\<br>F_n<br>\end{pmatrix}=\begin{pmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix}^n<br>\begin{pmatrix}<br>F_{1}\\<br>F_{0}<br>\end{pmatrix}<br>$$</p><p>下面用一个简单方法处理计算$\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^n$</p><p>$\text{令：}A=\begin{pmatrix}<br>1 &amp; 1\\<br>1 &amp; 0<br>\end{pmatrix},\text{那么}A^n=\begin{pmatrix}<br>F_{n+1} &amp; F_n\\<br>F_n &amp; F_{n-1}<br>\end{pmatrix}\text{归纳易证}$</p><p>$\text{所以}A^{2m}=\begin{pmatrix}<br>F_{2m+1} &amp; F_{2m}\\<br>F_{2m} &amp; F_{2m-1}<br>\end{pmatrix}=A^m\cdot A^m,\quad A^m=\begin{pmatrix}<br>F_{m+1} &amp; F_m\\<br>F_m &amp; F_{m-1}<br>\end{pmatrix}\\<br>\begin{align}<br>so:\begin{pmatrix}<br>F_{2m+1} &amp; F_{2m}\\<br>F_{2m} &amp; F_{2m-1}<br>\end{pmatrix}&amp;=<br>\begin{pmatrix}<br>F_{m+1} &amp; F_m\\<br>F_m &amp; F_{m-1}<br>\end{pmatrix}<br>\begin{pmatrix}<br>F_{m+1} &amp; F_m\\<br>F_m &amp; F_{m-1}<br>\end{pmatrix}\\<br>&amp;=\begin{pmatrix}<br>F_{m+1}^2+F_m^2 &amp; F_{m+1}F_m+F_m F_{m-1}\\<br>F_{m+1}F_m+F_m F_{m-1} &amp; F_{m}^2+F_{m-1}^2<br>\end{pmatrix} \end{align}$</p><p>$\Longrightarrow \begin{cases}<br>F_{2m+1}=F_{m+1}^2+F_m^2\\F_{2m}=F_m(F_{m+1}+ F_{m-1})<br>\end{cases}\text{得到了Fibonacci序列的另一种递推公式}$</p><ol><li>$n$为奇数，即$n=2m+1，\lfloor\frac{n}{2}\rfloor=m$<br>$$\begin{pmatrix}<br>F_{n+1}\\<br>F_{n}<br>\end{pmatrix}=\begin{pmatrix}<br>F_{2m+2}\\<br>F_{2m+1}<br>\end{pmatrix}=\begin{pmatrix}<br>(2F_{m}+F_{m+1})F_{m+1}\\<br>F_{m}^2+F_{m+1}^2<br>\end{pmatrix}$$</li><li>n为偶数，即$n=2m，\lfloor\frac{n}{2}\rfloor=m$<br>$$\begin{pmatrix}<br>F_{n+1}\\<br>F_{n}<br>\end{pmatrix}=\begin{pmatrix}<br>F_{2m+1}\\<br>F_{2m}<br>\end{pmatrix}=\begin{pmatrix}<br>F_{m}^2+F_{m+1}^2\\<br>(2F_{m+1}-F_{m})F_{m}<br>\end{pmatrix}$$</li></ol><blockquote><p>这里仅用第m项与第m+1项表达，计算过程中的m-1项和m+2项利用Fibonacci数列的递推公式代换掉了。</p></blockquote><p>所以对于$Fibonacci(n)$我们只需要计算$Fibonacci(n/2)=Fibonacci(m)$。其时间复杂度为$O(\log n)$，空间复杂度也为$O(\log n)$。</p><p>python代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    f_m, f_m1 = Fibonacci(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> f_m**<span class="number">2</span>+f_m1**<span class="number">2</span>, (<span class="number">2</span>*f_m+f_m1)*f_m1</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*f_m1-f_m)*f_m1, f_m**<span class="number">2</span>+f_m1**<span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;从Fibonacci序列谈起&quot;&gt;&lt;a href=&quot;#从Fibonacci序列谈起&quot; class=&quot;headerlink&quot; title=&quot;从Fibo
      
    
    </summary>
    
      <category term="计算机" scheme="https://love-chrissie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="算法" scheme="https://love-chrissie.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>多项式拟合</title>
    <link href="https://love-chrissie.github.io/2018/10/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%9F%E5%90%88/"/>
    <id>https://love-chrissie.github.io/2018/10/09/多项式拟合/</id>
    <published>2018-10-09T10:04:19.000Z</published>
    <updated>2018-12-29T11:14:56.628Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Dec 30 2018 20:25:52 GMT+0800 (CST) --><p>给定一个训练数据集：<br>$$T=\begin{Bmatrix}(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\end{Bmatrix}$$<br>其中，$x_i\in \mathbb{R}$是输入$x$的观测值，$y_i\in\mathbb{R}$是相应的输出$y$的观测值，$i=1,2,\cdots,N.$多项式拟合需要做的就是在$M$次多项式函数中选择一个对已知数据和未知数据都有很好的预测能力的函数。</p><p>设$M$次多项式函数为：</p><p>$$f_M(x,w)=w_0+w_1 x+w_2 x^2+\cdots+w_M x^M=\sum\limits_{j=0}^{M}w_j x^j$$<br>式中$x$是单变量输入，$w_0,w_1,\cdots,w_M$是$M+1$个参数。</p><p>选取平方损失为损失函数：</p><p>$$L(w)=\frac{1}{2}\sum\limits_{i=1}^{N}\bigg(\sum\limits_{j=0}^{M}w_j x_{i}^{j}-y_i\bigg)^2$$</p><p>对$w_j$求偏导并令其为$0$可得：<br>$$\frac{\partial L}{\partial w_j}=x_1^j (\sum\limits_{j=0}^{M}w_j x_1^j -y_1)+x_2^j (\sum\limits_{j=0}^{M}w_j x_2^j -y_2)+\cdots+x_N^j (\sum\limits_{j=0}^{M}w_j x_N^j -y_N)=0\Rightarrow \\<br>\sum\limits_{j=0}^{M}\sum\limits_{i=1}^{N}w_j x_i^j=\sum\limits_{i=1}^{N}x_i^j y_i$$</p><p>对于$j=0,1,\cdots,M$可得到如下线性方程组：<br>$$\begin{pmatrix}<br>\sum\limits_{i=1}^{N}x_i^0 &amp; \sum\limits_{i=1}^{N}x_i^1 &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^M \\<br>\sum\limits_{i=1}^{N}x_i^1 &amp; \sum\limits_{i=1}^{N}x_i^2 &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^{M+1} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\sum\limits_{i=1}^{N}x_i^M &amp; \sum\limits_{i=1}^{N}x_i^{M+1} &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^{M+M}<br>\end{pmatrix}\begin{pmatrix}<br>w_0\\<br>w_1\\<br>\vdots\\<br>w_M<br>\end{pmatrix}=\begin{pmatrix}<br>\sum\limits_{i=1}^{N}x_i^0 y_i \\<br>\sum\limits_{i=1}^{N}x_i^1 y_i \\<br>\vdots \\<br>\sum\limits_{i=1}^{N}x_i^M y_i<br>\end{pmatrix}$$<br>求解上述方程组即可得到拟合多项式系数 $w_0^{\ast},w_1^{\ast},\cdots,w_M^{\ast} $.</p><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">N = <span class="number">5</span> <span class="comment">#多项式的阶数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCoefficientMatrix</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> N</span><br><span class="line">    MeasureNumber = len(x)</span><br><span class="line">    A = np.zeros((N+<span class="number">1</span>,N+<span class="number">1</span>))</span><br><span class="line">    B = np.zeros(N+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(MeasureNumber):</span><br><span class="line">                A[i, j] += np.math.pow(x[k], i+j) <span class="comment">#生成系数矩阵每个系数，可以改进为先求出0次到2(N+1)次方的和，然后一一填入系数矩阵</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(MeasureNumber):</span><br><span class="line">            B[i] += np.math.pow(x[k], i)*y[k]</span><br><span class="line">    <span class="keyword">return</span> A, B</span><br><span class="line"></span><br><span class="line">A, B = getCoefficientMatrix(x,y)</span><br><span class="line">Omega = np.linalg.solve(A,B) <span class="comment">#线性方程组求解，自己编程实现可以使用推荐使用共轭梯度</span></span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Dec 30 2018 20:25:52 GMT+0800 (CST) --&gt;&lt;p&gt;给定一个训练数据集：&lt;br&gt;$$T=\begin{Bmatrix}(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\end{Bmat
      
    
    </summary>
    
      <category term="机器学习" scheme="https://love-chrissie.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="拟合" scheme="https://love-chrissie.github.io/tags/%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>高斯消去法</title>
    <link href="https://love-chrissie.github.io/2018/09/28/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95/"/>
    <id>https://love-chrissie.github.io/2018/09/28/高斯消去法/</id>
    <published>2018-09-28T03:18:07.000Z</published>
    <updated>2018-10-11T03:09:41.968Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>高斯消去法与$LU$分解</p><p>高斯消去法思想就是通过初等行变换将系数矩阵变换成上三角矩阵，最后一行就解出了最后一个未知数的值，向上回带即可得到结果。</p><p>计算过程就是第二行开始每一行乘以第一行的$\lambda_{i}$倍，使得每一行第一个系数为0，然后对每一行做同样操作循环下去（下一次从第三行开始，使每一行第二个系数为0），使得系数矩阵变成上三角矩阵。最后回带每个未知量，求得结果。</p><p>例，对于线性方程组$\boldsymbol{Ax}=\boldsymbol{b}$，其中：<br>$$<br>A=\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix},\quad<br>b=\begin{bmatrix}<br>4 \\<br>11 \\<br>29 \\<br>30<br>\end{bmatrix}.<br>$$<br>计算步骤：</p><p>$\begin{aligned}(\boldsymbol A |\boldsymbol b)&amp;\xrightarrow{第一次消元}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\<br>0 &amp; 3 &amp; 5 &amp; 5 &amp; 13\\<br>0 &amp; 4 &amp; 6 &amp; 8 &amp; 18<br>\end{bmatrix}\xrightarrow{第二次消元}\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\<br>0 &amp; 0 &amp; 2 &amp; 2 &amp; 4\\<br>0 &amp; 0 &amp; 2 &amp; 4 &amp; 6<br>\end{bmatrix}\\&amp;\xrightarrow{第三次消元}\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\<br>0 &amp; 0 &amp; 2 &amp; 2 &amp; 4\\<br>0 &amp; 0 &amp; 0 &amp; 2 &amp; 2<br>\end{bmatrix}=(\boldsymbol U|\boldsymbol c)\end{aligned}$</p><p>解上三角方程组$\boldsymbol{Ux}=\boldsymbol{c}$，得方程组得解为$\boldsymbol{x}=(1,1,1,1)^{T}$.<br>上述行变换可以用初等矩阵来描述：</p><p>$\boldsymbol L_1\boldsymbol A =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>-2 &amp; 1 &amp; 0 &amp; 0 \\<br>-4 &amp; 0 &amp; 1 &amp; 0 \\<br>-3 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix}=\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>0 &amp; 1 &amp; 1 &amp; 1 \\<br>0 &amp; 3 &amp; 5 &amp; 5 \\<br>0 &amp; 4 &amp; 6 &amp; 8<br>\end{bmatrix}$</p><p>$\begin{aligned}\boldsymbol L_2\boldsymbol L_1\boldsymbol A &amp;=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; -3 &amp; 1 &amp; 0 \\<br>0 &amp; -4 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>-2 &amp; 1 &amp; 0 &amp; 0 \\<br>-4 &amp; 0 &amp; 1 &amp; 0 \\<br>-3 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix}\\&amp;=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>-2 &amp; 1 &amp; 0 &amp; 0 \\<br>-4 &amp; -3 &amp; 1 &amp; 0 \\<br>-3 &amp; -4 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix}=<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>0 &amp; 1 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 2 &amp; 2 \\<br>0 &amp; 0 &amp; 2 &amp; 4<br>\end{bmatrix}\end{aligned}$</p><p>$\begin{aligned}\boldsymbol L_3\boldsymbol L_2\boldsymbol L_1\boldsymbol A &amp;=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; -1 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; -3 &amp; 1 &amp; 0 \\<br>0 &amp; -4 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>-2 &amp; 1 &amp; 0 &amp; 0 \\<br>-4 &amp; 0 &amp; 1 &amp; 0 \\<br>-3 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix}\\<br>&amp;=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>-2 &amp; 1 &amp; 0 &amp; 0 \\<br>-4 &amp; -3 &amp; 1 &amp; 0 \\<br>-3 &amp; -4 &amp; -1 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>4 &amp; 3 &amp; 3 &amp; 1 \\<br>8 &amp; 7 &amp; 9 &amp; 5 \\<br>6 &amp; 7 &amp; 9 &amp; 8<br>\end{bmatrix}=<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>0 &amp; 1 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 2 &amp; 2 \\<br>0 &amp; 0 &amp; 0 &amp; 2<br>\end{bmatrix}=\boldsymbol U\end{aligned}$</p><p>所以：</p><p>$\boldsymbol A=\boldsymbol L \boldsymbol U=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0 \\<br>2 &amp; 1 &amp; 0 &amp; 0 \\<br>4 &amp; 3 &amp; 1 &amp; 0 \\<br>3 &amp; 4 &amp; 1 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>2 &amp; 1 &amp; 1 &amp; 0 \\<br>0 &amp; 1 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 2 &amp; 2 \\<br>0 &amp; 0 &amp; 0 &amp; 2<br>\end{bmatrix}$</p><p>高斯消去法先得到上三角矩阵再回代求解，而$LU$分解先对系数矩阵$A$分解成两上下三角矩阵，然后两次回代求解。一般编程语言的科学计算库都是使用$LU$分解求线性方程组。</p><p><strong>定理</strong> 若$n$阶方阵逐次（左上角）主子式$det A_k\neq 0,k=1,2,\cdots,n$，则$A$可以分解为单位下三角矩阵和上三角矩阵。顺序Gauss消去法可以顺利进行。</p><table><thead><tr><th>高斯消去法</th><th>$LU$分解</th></tr></thead><tbody><tr><td>$Ax=b\\ \quad\Downarrow\\Ux=c$</td><td>$A=LU\\ Ly=b\\Ux=y$</td></tr></tbody></table><blockquote><p>如上讨论的是顺序Gauss消去法，即除数$A(k,k)$不为0，或者说除数不能为0。当我们遇到除数$A(k,k)$为0的时候就需要进行行交换，将$A(k,k)=0$时的k行换到下方去。</p></blockquote><p><a href="https://book.douban.com/subject/4247269/" target="_blank" rel="noopener">《科学计算和C程序集》</a>的高斯消去法代码：<a href="https://github.com/Love-Chrissie/numerical-computation/blob/master/gelim.c" target="_blank" rel="noopener">https://github.com/Love-Chrissie/numerical-computation/blob/master/gelim.c</a></p><p>python代码如下:<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入系数矩阵应以numpy中的array类型输入</span></span><br><span class="line"><span class="comment"># LU分解又称doolittle分解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doolittle</span><span class="params">(a, n)</span>:</span></span><br><span class="line">    <span class="comment"># 主行</span></span><br><span class="line">    l = np.eye(n)</span><br><span class="line">    u = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 乘子，用于消去第j行的i列</span></span><br><span class="line">            a[j, i] = a[j, i] / a[i, i]</span><br><span class="line">            <span class="comment"># 对i+1...n-1列</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                a[j, k] = a[j, k] - a[j, i] * a[i, k]  <span class="comment"># 消元</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> (j &lt; i):</span><br><span class="line">                l[i, j] = a[i, j]  <span class="comment"># 下三角矩阵</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                u[i, j] = a[i, j]  <span class="comment"># 上三角矩阵</span></span><br><span class="line">    <span class="keyword">return</span> a,l,u</span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;高斯消去法与$LU$分解&lt;/p&gt;&lt;p&gt;高斯消去法思想就是通过初等行变换将系数矩阵变换成上三角矩阵，最后一行就解出了最后一个未知数的值，向上回带即可得到结果
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="矩阵与数值分析" scheme="https://love-chrissie.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>变限积分的导数与雷诺运输定理</title>
    <link href="https://love-chrissie.github.io/2018/09/26/%E5%8F%98%E9%99%90%E7%A7%AF%E5%88%86%E7%9A%84%E5%AF%BC%E6%95%B0%E4%B8%8E%E9%9B%B7%E8%AF%BA%E8%BF%90%E8%BE%93%E5%AE%9A%E7%90%86/"/>
    <id>https://love-chrissie.github.io/2018/09/26/变限积分的导数与雷诺运输定理/</id>
    <published>2018-09-26T15:40:51.000Z</published>
    <updated>2018-09-27T11:01:49.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>变限积分求导，我是这么俗称这个公式的，维基百科称为<a href="https://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign" target="_blank" rel="noopener">积分符号内取微分</a></p><p>$$<br>\dfrac{d}{dt}\int\limits_{\alpha(t)}^{\beta(t)} f(x,t)dx=\int\limits_{\alpha(t)}^{\beta(t)} \frac{\partial f(x,t)}{\partial t}dx+\beta^{\prime}(t)f(\beta(t),t)-\alpha^{\prime}(t)f(\alpha(t),t)<br>$$</p><p>最开始是搞数学竞赛的时候看别的大神炫技学会的，然后看了<a href="https://book.douban.com/subject/1728600/" target="_blank" rel="noopener">微积分学教程</a>又巩固了一遍，一般数学分析书都有证明。这个公式在《<a href="https://spaces.ac.cn/archives/1615" target="_blank" rel="noopener">别闹了，费曼</a>》中也有介绍。<br>变限积分求导公式是个很一般的公式，这里提到它是因为在复习<strong>雷诺运输定理</strong>的时候发现了他两之间的联系——雷诺运输定理也就是变限积分求导公式的三维情况。</p><p><strong>雷诺运输定理：</strong></p><p>对于随时间变化的区域$\Omega (t)$，其边界为$\partial \Omega (t)$，该区域内对$\boldsymbol{f}=\boldsymbol{f}(x,t)$的积分的导数为：<br>$$<br>\dfrac{d}{dt} \big( \int _{\Omega (t)} \boldsymbol{f}\,{dV} \big) =\int _{\Omega (t)} {\frac{\partial \boldsymbol{f}}{\partial t}}\,{dV}+\int _{\partial \Omega (t)} ({\vec {v}} \cdot {\vec {n}} ) \boldsymbol{f}\, {dA} .<br>$$</p><p></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;变限积分求导，我是这么俗称这个公式的，维基百科称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Differentiatio
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="导数" scheme="https://love-chrissie.github.io/tags/%E5%AF%BC%E6%95%B0/"/>
    
      <category term="积分" scheme="https://love-chrissie.github.io/tags/%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>范数</title>
    <link href="https://love-chrissie.github.io/2018/09/25/%E8%8C%83%E6%95%B0/"/>
    <id>https://love-chrissie.github.io/2018/09/25/范数/</id>
    <published>2018-09-24T23:51:53.000Z</published>
    <updated>2018-09-30T10:20:47.123Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>定义</strong>：定义在$ {\mathbb{C}}^n $上的一个非负实值函数，记为$\parallel\cdot\parallel$，若该函数满足以下三个条件：即对任意向量$\boldsymbol x$和$\boldsymbol y$以及任意常数$\alpha \in \mathbb{C}$</p><ol><li>$\parallel \boldsymbol x \parallel\geq 0$,并且$\parallel \boldsymbol x \parallel= 0$的充要条件为$\boldsymbol x =\boldsymbol 0$;</li><li>$\parallel \alpha \boldsymbol x \parallel=|\alpha|\, \parallel\boldsymbol x\parallel$,</li><li>$\parallel \boldsymbol x + \boldsymbol y\parallel \leq \parallel\boldsymbol x\parallel+\parallel\boldsymbol y\parallel$,</li></ol><p>则称$\parallel\cdot\parallel$为上${\mathbb{C}}^n$的一个<strong>向量范数</strong></p><p>一类有用的向量范数为$p$范数，定义为：<br>$$<br>\parallel \boldsymbol x \parallel_{p}=(\sum \limits_{i=1}^{n} |x_i|^{p})^{\frac{1}{p}},\quad p\geq1<br>$$<br>其中最重要的是$1$范数，$2$范数，$\infty$范数<br>$$<br>\begin{align}<br>&amp; \parallel \boldsymbol x \parallel_{1}=\sum \limits_{i=1}^{n} |x_i|;\\<br>&amp; \parallel \boldsymbol x \parallel_{2}=(\sum \limits_{i=0}^{n} |x_i|^{2})^{\frac{1}{2}};\\<br>&amp; \parallel \boldsymbol x \parallel_{\infty}=\max \limits_{1\leq i\leq n} |x_i|.<br>\end{align}<br>$$<br>其中$\infty$范数形式的得出只要利用$p$范数，对$p$取$\infty$即可，证明略。</p><p>另一常用范数是加权的$p$范数可以表示为：<br>$$<br>\parallel\boldsymbol x\parallel_{\boldsymbol W} =\parallel\boldsymbol{Wx}\parallel,<br>$$<br>其中$\boldsymbol W$为对角矩阵，其对角元即为它每个分量的加权系数，更一般地可以取$\boldsymbol W$为任意非奇异矩阵。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>关于$p$范数的一个经典性质是<a href="https://en.wikipedia.org/wiki/H%C3%B6lder%27s_inequality" target="_blank" rel="noopener">Hölder不等式</a>：<br>$$\parallel{\boldsymbol x}^{T} \boldsymbol y\parallel_1 \leq \parallel\boldsymbol x\parallel_p \parallel\boldsymbol y\parallel_q,\quad \frac{1}{p}+\frac{1}{q}=1.$$<br>对于$2$范数就是著名的Cauchy–Schwarz不等式:<br>$$\parallel{\boldsymbol x}^{T} \boldsymbol y\parallel_1 \leq \parallel\boldsymbol x\parallel_2 \parallel\boldsymbol y\parallel_2.$$<br>对于$p$范数，其对应的三角不等式即为<a href="https://en.wikipedia.org/wiki/Minkowski_inequality" target="_blank" rel="noopener">闵可夫斯基不等式</a>:<br>$$\parallel \boldsymbol x + \boldsymbol y\parallel_p \leq \parallel\boldsymbol x\parallel_p+\parallel\boldsymbol y\parallel_p.$$</p><details><br><summary>下面证明之（利用到了Hölder不等式）：</summary><br>$$<br>\begin{align}<br>(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}\cdot p}<br>&amp; = \sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |x_i+y_i| \\<br>&amp; \leq \sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |x_i|+\sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |y_i|\\<br>&amp; \leq (\sum \limits_{i=1}^{n}|x_i+y_i|^{q(p-1)})^{\frac{1}{q}}(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+ (\sum \limits_{i=1}^{n}|x_i+y_i|^{q(p-1)})^{\frac{1}{q}}(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}},\,\text{Hölder’s inequality}\\<br>&amp; = \Big[(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}}\Big] (\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}}<br>\end{align}<br>$$<br><br>两边同时除以$(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{q}}$即可得到闵可夫斯基不等式，如下所示：<br>$$<br>(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}}<br>\leq<br>(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}}<br>$$<br></details><h5 id="范数的等价性"><a href="#范数的等价性" class="headerlink" title="范数的等价性"></a>范数的等价性</h5><p><strong>范数的等价性定理</strong>：设$\parallel\cdot\parallel_{\alpha}$和$\parallel\cdot\parallel_{\beta}$为${\mathbb{C}}^n$上的任意两种向量范数，则存在两个与向量$\parallel\boldsymbol x\parallel$无关的正常数$c_1$和$c_2$，使得下面的不等式成立：<br>$$<br>c_1 \parallel\boldsymbol x\parallel_{\beta}\leq \parallel\boldsymbol x\parallel_{\alpha}\leq c_2 \parallel\boldsymbol x\parallel_{\beta},\quad \boldsymbol x \in {\mathbb{C}}^{\,n}<br>$$<br>并称$\parallel \cdot \parallel_{\alpha}$和$\parallel \cdot \parallel_{\beta}$为${\mathbb{C}}^{\, n}$上的<strong>等价范数</strong>。<br>以下为三个常见不等式：</p><ol><li>$\parallel\boldsymbol x\parallel_{\infty}\leq\parallel\boldsymbol x\parallel_1\leq n\parallel\boldsymbol x\parallel_{\infty}$;</li><li>$\frac{1}{\sqrt n}\parallel\boldsymbol x\parallel_1\leq\parallel\boldsymbol x\parallel_2\leq \parallel\boldsymbol x\parallel_1$;</li><li>$\frac{1}{\sqrt n}\parallel\boldsymbol x\parallel_2\leq\parallel\boldsymbol x\parallel_{\infty}\leq \parallel\boldsymbol x\parallel_2$.</li></ol><h3 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个$m\times n$矩阵可以看成$mn$维向量空间中的一个向量，故矩阵范数的定义等价于向量范数的定义。</p><p><strong>定义</strong>：定义在${\mathbb{C}}^{m\times n}$上的一个非负实值函数，记为$\parallel\cdot\parallel$。若$\forall \boldsymbol A,\boldsymbol B\in {\mathbb{C}}^{m\times n}$均满足以下条件：</p><ol><li>非负性：$\parallel \boldsymbol A \parallel\geq 0$,并且$\parallel \boldsymbol A \parallel= 0$的充要条件为$\boldsymbol A =\boldsymbol 0$;</li><li>齐次性：$\parallel \alpha \boldsymbol A \parallel=|\alpha|\, \parallel\boldsymbol A\parallel,c\in \mathbb{C}$</li><li>三角不等式：$\parallel \boldsymbol A + \boldsymbol B\parallel \leq \parallel\boldsymbol A\parallel+\parallel\boldsymbol B\parallel$,</li></ol><p>则称$\parallel\cdot\parallel$为${\mathbb{C}}^{m\times n}$上的矩阵范数。</p><p><strong>相容性</strong>：如果对所有$\boldsymbol A\in \mathbb{R}^{m\times n}$和$\boldsymbol B\in \mathbb{R}^{n\times q}$有$f_1 (\boldsymbol{AB})\leq f_2 (\boldsymbol A)f_3 (\boldsymbol B)$，则称$\mathbb{R}^{m\times q}$，$\mathbb{R}^{m\times n}$和$\mathbb{R}^{n\times q}$上的范数$f_1$，$f_2$和$f_3$是相互相容的。</p><blockquote><p>有的书上矩阵范数特指满足相容性条件的范数。<br>下面考虑的矩阵范数均是满足相容性的矩阵范数。</p></blockquote><p>其中最常用的矩阵范数有$F$范数（Frobenius范数）：<br>$$<br>\parallel\boldsymbol A\parallel_{F}=\sqrt{\sum\limits_{i=1}^m \sum\limits_{j=1}^n |a_{ij}|^2}<br>$$<br>和$p$范数:<br>$$<br>\parallel\boldsymbol A\parallel_{p}=\sup\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\frac{\parallel\boldsymbol{Ax}\parallel_p}{\parallel\boldsymbol x\parallel_p}<br>$$<br>很明显，$\parallel\boldsymbol A\parallel_p$是将$\boldsymbol A$作用到$p$范数单位向量所得到的最大向量的$p$范数：</p><p></p><h4 id="由向量范数导出矩阵范数"><a href="#由向量范数导出矩阵范数" class="headerlink" title="由向量范数导出矩阵范数"></a>由向量范数导出矩阵范数</h4><p>给定$\mathbb{C}^n$上的向量范数$\parallel\cdot\parallel$，$\boldsymbol A$为$m\times n$矩阵，定义：<br>$$<br>\parallel\boldsymbol{A}\parallel=\sup\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\bigg(\frac{\parallel\boldsymbol {Ax}\parallel}{\parallel\boldsymbol x\parallel}\bigg)=\sup_{\parallel\boldsymbol{x}\parallel=1}{\parallel\boldsymbol {Ax}\parallel}<br>$$<br>并称$\parallel\cdot\parallel$为向量范数诱导的矩阵范数，简称算子范数。</p><h4 id="p-范数诱导的矩阵范数"><a href="#p-范数诱导的矩阵范数" class="headerlink" title="p-范数诱导的矩阵范数"></a>p-范数诱导的矩阵范数</h4><p>$\mathbb{C}^m$和$\mathbb{C}^n$空间上装备的向量范数都是$p$范数时，其诱导的矩阵范数也称为<strong>诱导$p$范数</strong></p><p>$$<br>\parallel \boldsymbol{A} \parallel_{p}=\sup\limits_{x \neq 0}\parallel\boldsymbol{A}\Big(\frac{\boldsymbol x}{ \parallel\boldsymbol x \parallel_p}\Big)\parallel_p=\max \limits_{\parallel\boldsymbol x\parallel_p=1}\parallel\boldsymbol{Ax}\parallel_p=\max\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\frac{\Big(\sum\limits_{i=1}^{n}|\sum\limits_{j=1}^{m}A_{ij}x_j|^p\Big)^{\frac{1}{p}}}{(\sum\limits_{i=1}^{m}|x_i|^p)^{\frac{1}{p}}}.<br>$$</p><p>对于诱导$p$范数，有三种常用范数：</p><ol><li>$\parallel \boldsymbol{A} \parallel_{1}=\max\limits_{1\leq j\leq n}\sum\limits_{i=1}^{m}|a_{ij}|;$</li><li>$\parallel \boldsymbol{A} \parallel_{2}=\sqrt{\lambda_{\max}(\boldsymbol{A^{H}A})}$</li><li>$\parallel \boldsymbol{A} \parallel_{\infty}=\max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|;$</li></ol><details><br><summary>这里给出3的证明</summary><br>$$<br>\parallel \boldsymbol{Ax} \parallel_{\infty}=\max \limits_{1\leq i\leq n}\big|\sum\limits_{j=1}^{n}a_{ij}x_j\big|\leq \max \limits_{1\leq i\leq n}\sum\limits_{j=1}^{n}|a_{ij}x_j|\leq\max \limits_{1\leq i\leq n}\sum\limits_{j=1}^{n}|a_{ij}|\parallel \boldsymbol x\parallel_{\infty} \leq \parallel A \parallel_{\infty}\parallel \boldsymbol x \parallel_{\infty},<br>$$<br>因此:<br>$$<br>\parallel \boldsymbol A \parallel_{\infty}=\max\limits_{\boldsymbol{x}\neq\boldsymbol{0}}\frac{\parallel \boldsymbol{Ax}\parallel_{\infty}}{\parallel \boldsymbol{x}\parallel_{\infty}}\leq \max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|<br>$$<br>假定$\boldsymbol A$的第$k$行非零，且定义向量$z\in\mathbb{C}^n$为:<br><img src="/images/fanshu.png" width="240" height="240"><br>于是$\parallel \boldsymbol z \parallel_{\infty}=1$，且对所有$j=1,2,\dots ,n$，有$a_{kj}z_{j}=|a_{kj}|$，并且<br>$$<br>\max\limits_{\parallel \boldsymbol x\parallel_{\infty}=1}\parallel \boldsymbol{Ax}\parallel_{\infty}\geq\parallel \boldsymbol{Az}\parallel_{\infty}=\max\limits_{1\leq i\leq n}\big|\sum\limits_{j=1}^{n}a_{ij}z_{j}\big|\geq\big|\sum\limits_{j=1}^{n}a_{kj}z_{j}\big|=\sum\limits_{j=1}^{n}|a_{kj}|.<br>$$<br>因此<br>$$<br>\max\limits_{\parallel \boldsymbol x\parallel_{\infty}=1}\parallel \boldsymbol{Ax}\parallel_{\infty}\geq \max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|<br>$$<br></details><p>对于以上三个矩阵范数，我们有：</p><p>$$<br>\parallel \boldsymbol{A} \parallel _{2}^{2} \leq\parallel \boldsymbol{A} \parallel _{1}\, \parallel \boldsymbol{A} \parallel _{\infty}<br>$$</p><p><strong>推论</strong> 对任何算子范数，单位矩阵$\boldsymbol I$的范数为1。</p><blockquote><p>练习：设$\boldsymbol A$为n阶非奇异矩阵，$\boldsymbol U$为n阶酉矩阵,，证明：</p><p>$\parallel \boldsymbol U\parallel_2=1$;</p><p>$\parallel \boldsymbol{AU}\parallel_2=\parallel \boldsymbol{UA}\parallel_2=\parallel \boldsymbol{A}\parallel_2$;</p><p>$\parallel \boldsymbol{A}\parallel_F=\parallel \boldsymbol{UA}\parallel_F=\parallel \boldsymbol{AV}\parallel_F=\parallel \boldsymbol{UAV}\parallel_F$</p></blockquote><p><strong>定义：</strong><br>矩阵$\boldsymbol A$的<strong>谱</strong>为：$\sigma(\boldsymbol{A})=$ &#123; $\lambda \big|\lambda $为$\boldsymbol{A}$的特征值 &#125;。<br>矩阵$\boldsymbol A$的<strong>谱半径</strong>为：$\rho(\boldsymbol{A})=\max$ &#123; $|\lambda| \big|\lambda $为$\boldsymbol{A}$的特征值 &#125;。</p><p><strong>定理</strong> 设$\parallel\cdot\parallel$为$\mathbb{C}^{n\times n}$矩阵空间的一种矩阵范数，则对任意的n阶方阵$\boldsymbol A$均有：<br>$$<br>\rho(\boldsymbol A)\leq \parallel \boldsymbol A \parallel.<br>$$<br>特别的，当$\boldsymbol A$为对称矩阵时:<br>$$<br>\rho(\boldsymbol A)=\parallel \boldsymbol A \parallel_{2}.<br>$$<br><strong>定理</strong> 对于任意$\varepsilon &gt; 0$,存在$\mathbb{C}^{n\times n}$矩阵空间的一种算子范数$\parallel\cdot\parallel$有：<br>$$<br>\parallel \boldsymbol A \parallel\leq\rho(\boldsymbol A)+\varepsilon.<br>$$</p><p><strong>定理</strong> 设$\boldsymbol A \in \mathbb{C}^{n\times n}$，如果有$\mathbb{C}^{n\times n}$上的一种矩阵范数$\parallel\cdot\parallel$使得$\parallel \boldsymbol A\parallel &lt; 1$，则：</p><ol><li>矩阵$\boldsymbol I \pm \boldsymbol A$可逆；</li><li>$\parallel(\boldsymbol I \pm \boldsymbol A)^{-1}\parallel \leq \frac{\parallel \boldsymbol I \parallel}{1-\parallel \boldsymbol A \parallel}$</li><li>$\parallel \boldsymbol{A}(\boldsymbol I \pm \boldsymbol A)^{-1}\parallel \leq \frac{\parallel \boldsymbol A \parallel}{1-\parallel \boldsymbol A \parallel}$</li></ol><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;向量范数&quot;&gt;&lt;a href=&quot;#向量范数&quot; class=&quot;headerlink&quot; title=&quot;向量范数&quot;&gt;&lt;/a&gt;向量范数&lt;/h3&gt;&lt;h4 id
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="矩阵与数值分析" scheme="https://love-chrissie.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    
      <category term="范数" scheme="https://love-chrissie.github.io/tags/%E8%8C%83%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>fusc function problem of Kata</title>
    <link href="https://love-chrissie.github.io/2018/09/23/fuscFunction/"/>
    <id>https://love-chrissie.github.io/2018/09/23/fuscFunction/</id>
    <published>2018-09-23T12:28:11.000Z</published>
    <updated>2018-09-27T07:17:29.617Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>This Kata is a continuation of <a href="http://www.codewars.com/kata/the-fusc-function-part-1" target="_blank" rel="noopener">Part 1</a>. The <code>fusc</code> function is defined recursively as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fusc(0) = 0</span><br><span class="line">fusc(1) = 1</span><br><span class="line">fusc(2n) = fusc(n)</span><br><span class="line">fusc(2n + 1) = fusc(n) + fusc(n + 1)</span><br></pre></td></tr></table></figure><p>Your job is to produce the code for the <code>fusc</code> function. In this kata, your function will be tested with large values of <code>n</code> (more than 1000 bits), so you should be concerned about stack overflow and timeouts.</p><p><strong>NOTE: In JavaScript and PHP, your function will be tested with n up to 52 bits. This will still require a non-naive solution. This will also overflow 32-bit operators, but it will be integer arithmetic.</strong></p><p>Hint: Define <code>F(n, a, b) = a * fusc(n) + b * fusc(n + 1)</code> and provide a recursive definition of <code>F</code> <em>without</em> referencing <code>fusc</code>.</p><p>上面是我之前做这题时候的描述，现在再看<a href="http://www.codewars.com/kata/the-fusc-function-part-1" target="_blank" rel="noopener">这题</a>，题目描述都不一样了。。之前直接递归可能是测试数太大了，直接超出最大递归深度。现在这题改了可以通过了，代码就不贴了。<br>但是之前谷歌搜了半天搜到了一个叫<a href="http://mathworld.wolfram.com/SternsDiatomicSeries.html" target="_blank" rel="noopener">Stern’s Diatomic Series</a>的东西，很有意思，这个递推公式的通项可以写成如下形式：</p><p>$$ a_{0}=0,a_{1}=1,a_{n}=\sum_{k=0}^{n-1}\limits \binom{k}{n-k-1}(mod\,2). $$</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;This Kata is a continuation of &lt;a href=&quot;http://www.codewars.com/kata/the-fusc-
      
    
    </summary>
    
      <category term="计算机" scheme="https://love-chrissie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="递归" scheme="https://love-chrissie.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="Kata" scheme="https://love-chrissie.github.io/tags/Kata/"/>
    
  </entry>
  
  <entry>
    <title>无理数小数部分的稠密性</title>
    <link href="https://love-chrissie.github.io/2018/09/23/%E4%B8%80%E9%81%93%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E9%A2%98/"/>
    <id>https://love-chrissie.github.io/2018/09/23/一道数学证明题/</id>
    <published>2018-09-23T12:28:11.000Z</published>
    <updated>2018-09-27T07:17:05.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>引理: $s·k$ 的小数部分在区间$[0,1]$上稠密，其中$s$为无理数，$k$为整数。<br>$prove:$即证明对任意正整数$m$，存在整数k使得 0 &#60; &#123; $ks$ &#125; &#60; $\frac {1} {m} $。将[0,1]区间分成m份$[0,\frac{1}{m})$，$[\frac{1}{m},\frac{2}{m})$ ，$\cdots$，$[\frac{m-1}{m},1]$，由抽屉原理可知，对于序列 &#123; &#123; $ts$ &#125; &#125; ,$(t=1,2,\cdots,m+1)$至少存在两者位于同一个小段区间内，假设为&#123; $ps$ &#125;, &#123; $qs$ &#125;，即0 &#60; &#123;$ps$&#125; $-$ &#123;$qs$&#125; &#60; $\frac{1}{m}$.取$k=p-q$即可。</p><p>问题：证明$\lim \limits_{x\rightarrow0^+} \frac{1}{x}-\lfloor \frac{1}{x} \rfloor$极限不存在。</p><p>$prove:$设$s$为无理数，$k$为正整数$(k=1,2,\cdots,n,\cdots)$。取$x=\frac{1}{ks}$，由引理知序列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;在$[0,1]$内稠密，故序列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;极限不存在，即$x\rightarrow 0^+ $时，存在子列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;，极限不存在，即$\lim \limits_{x\rightarrow0^+} \frac{1}{x}-\lfloor \frac{1}{x} \rfloor$极限不存在。</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;引理: $s·k$ 的小数部分在区间$[0,1]$上稠密，其中$s$为无理数，$k$为整数。&lt;br&gt;$prove:$即证明对任意正整数$m$，存在整数k使得
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="无理数" scheme="https://love-chrissie.github.io/tags/%E6%97%A0%E7%90%86%E6%95%B0/"/>
    
      <category term="稠密性" scheme="https://love-chrissie.github.io/tags/%E7%A8%A0%E5%AF%86%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>组合问题递归实现</title>
    <link href="https://love-chrissie.github.io/2018/09/23/%E7%BB%84%E5%90%88/"/>
    <id>https://love-chrissie.github.io/2018/09/23/组合/</id>
    <published>2018-09-23T12:28:11.000Z</published>
    <updated>2018-09-27T07:17:19.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="组合问题递归实现"><a href="#组合问题递归实现" class="headerlink" title="组合问题递归实现"></a>组合问题递归实现</h3><p>问题：在n个不同物体中选取k个，列举出所有选取情况。</p><blockquote><p>思路很简单就是按照数数的方式把每种情况数出来，也就是第一次选取一个物体，第二次在剩余的中选取一个，直到选取k个。用数学公式就是帕斯卡公式$$C_{n}^{k}=C_{n}^{k-1}+C_{n-1}^{k-1}\Rightarrow C_{n}^{k}=\sum \limits_{s=0}^{k-1}{k-1 \choose s}C_{n-s}^{1}$$</p></blockquote><p>Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">project为n个不同的物体</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(project, n, k, K, lst2)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, k<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        lst2[k<span class="number">-1</span>] = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">1</span>:</span><br><span class="line">            combine(project, i<span class="number">-1</span>, k<span class="number">-1</span>, K, lst2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(K<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                print(project[lst2[j]],end=<span class="string">''</span>)</span><br><span class="line">            print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;组合问题递归实现&quot;&gt;&lt;a href=&quot;#组合问题递归实现&quot; class=&quot;headerlink&quot; title=&quot;组合问题递归实现&quot;&gt;&lt;/a&gt;组合问
      
    
    </summary>
    
      <category term="计算机" scheme="https://love-chrissie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="python" scheme="https://love-chrissie.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>老鼠和毒药</title>
    <link href="https://love-chrissie.github.io/2018/09/23/%E8%80%81%E9%BC%A0%E5%92%8C%E6%AF%92%E8%8D%AF/"/>
    <id>https://love-chrissie.github.io/2018/09/23/老鼠和毒药/</id>
    <published>2018-09-23T12:28:11.000Z</published>
    <updated>2018-09-27T07:16:55.893Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><p>有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？</p><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>我们有100个囚犯，这100个囚犯要枪毙。首先100个囚犯站一排报数，报到奇数就枪毙，报到偶数就留下，留下之后再站一排，然后同样规则继续枪毙，直到剩下一个人就把它放了，问：如果你想要被放掉，你最开始应该站在什么位置？</p><h3 id="推广："><a href="#推广：" class="headerlink" title="推广："></a>推广：</h3><p>如果你有两个星期的时间（换句话说你可以做两轮实验），为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？注意，在第一轮实验中死掉的老鼠，就无法继续参与第二次实验了。</p><h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><details><br><summary>点击查看</summary><br><p>将1000个瓶子按0～999标号并表示成10位二进制数的形式，第一个老鼠喝所有瓶子编号第一位为1的瓶子，第二个老鼠喝所有瓶子编号第二位为1的瓶子，以此类推，第十个老鼠就喝所有瓶子编号第十位为1的瓶子。一星期后，第几只老鼠死了就在第几位上写下1，没死就写上0，这样就得到瓶子的编号了，很明显10只老鼠最大验证毒药瓶子数为$2^{10}=1024$。</p><br><p>思考：64号位置，枪毙规律就是100个编号(1,2,$\cdots$,100)无限次每次地板除2，每次保留没有余数的，直到只剩一个数为止，余下的那个数这必然是$2^n$。</p><br><p>推广自行思考。</p><br></details><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;p&gt;有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时
      
    
    </summary>
    
      <category term="数学" scheme="https://love-chrissie.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="二进制" scheme="https://love-chrissie.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>关hexo写latex数学公式的一些雷区</title>
    <link href="https://love-chrissie.github.io/2018/09/23/markdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://love-chrissie.github.io/2018/09/23/markdown中写数学公式的一个问题/</id>
    <published>2018-09-23T12:28:11.000Z</published>
    <updated>2018-09-27T07:17:40.752Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --><h3 id="特殊符号的转义问题"><a href="#特殊符号的转义问题" class="headerlink" title="特殊符号的转义问题"></a>特殊符号的转义问题</h3><p>在markdown中使用latex数学公式时候，不可在数学公式环境下&#40; &#36;&#36;包括进去的部分 &#41;使用&#92;进行转义，否则hexo生成会报错。比如大括号&#123;，不要在数学公式环境内使用&#92;&#123;转义，而应该使用&amp;#123;。<br>一些markdown需要转义字符如下：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">html代码</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">&#33;</td><td style="text-align:center">&amp;#33;</td><td style="text-align:center">惊叹号</td></tr><tr><td style="text-align:center">&#34;</td><td style="text-align:center">&amp;#34;</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">&#35;</td><td style="text-align:center">&amp;#35;</td><td style="text-align:center">数字标志</td></tr><tr><td style="text-align:center">&#36;</td><td style="text-align:center">&amp;#36;</td><td style="text-align:center">百分号</td></tr><tr><td style="text-align:center">&#37;</td><td style="text-align:center">&amp;#37;</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">&#38;</td><td style="text-align:center">&amp;#38;</td><td style="text-align:center">左小括号</td></tr><tr><td style="text-align:center">&#39;</td><td style="text-align:center">&amp;#39;</td><td style="text-align:center">右小括号</td></tr><tr><td style="text-align:center">&#40;</td><td style="text-align:center">&amp;#40;</td><td style="text-align:center">惊叹号</td></tr><tr><td style="text-align:center">&#41;</td><td style="text-align:center">&amp;#41;</td><td style="text-align:center">加号</td></tr><tr><td style="text-align:center">&#42;</td><td style="text-align:center">&amp;#42;</td><td style="text-align:center">小于号</td></tr><tr><td style="text-align:center">&#43;</td><td style="text-align:center">&amp;#43;</td><td style="text-align:center">等于号</td></tr><tr><td style="text-align:center">&#60;</td><td style="text-align:center">&amp;#60;</td><td style="text-align:center">大于号</td></tr><tr><td style="text-align:center">&#61;</td><td style="text-align:center">&amp;#61;</td><td style="text-align:center">问号</td></tr><tr><td style="text-align:center">&#64;</td><td style="text-align:center">&amp;#64;</td><td style="text-align:center">Commercial at</td></tr><tr><td style="text-align:center">&#91;</td><td style="text-align:center">&amp;#91;</td><td style="text-align:center">左中括号</td></tr><tr><td style="text-align:center">&#92;</td><td style="text-align:center">&amp;#92;</td><td style="text-align:center">反斜杠</td></tr><tr><td style="text-align:center">&#93;</td><td style="text-align:center">&amp;#93;</td><td style="text-align:center">右中括号</td></tr><tr><td style="text-align:center">&#123;</td><td style="text-align:center">&amp;#123;</td><td style="text-align:center">左大括号</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">&amp;#124;</td><td style="text-align:center">竖线</td></tr><tr><td style="text-align:center">&#125;</td><td style="text-align:center">&amp;#125;</td><td style="text-align:center">右大括号</td></tr></tbody></table><h3 id="数学环境下的换行问题"><a href="#数学环境下的换行问题" class="headerlink" title="数学环境下的换行问题"></a>数学环境下的换行问题</h3><p><strong>我们需要\\\\（四个）而不是\\（俩个）实现换行，因为markdown会将反斜杠视作转义</strong></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Dec 29 2018 17:44:33 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;特殊符号的转义问题&quot;&gt;&lt;a href=&quot;#特殊符号的转义问题&quot; class=&quot;headerlink&quot; title=&quot;特殊符号的转义问题&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="计算机" scheme="https://love-chrissie.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="markdown" scheme="https://love-chrissie.github.io/tags/markdown/"/>
    
      <category term="latex" scheme="https://love-chrissie.github.io/tags/latex/"/>
    
  </entry>
  
</feed>
