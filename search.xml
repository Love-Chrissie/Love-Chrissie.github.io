<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二阶非齐次常系数线性微分方程解法]]></title>
    <url>%2F2018%2F12%2F29%2F%E4%BA%8C%E9%98%B6%E9%9D%9E%E9%BD%90%E6%AC%A1%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高数中在求解形如$y’’+py’+q=f(x)$的二阶常系数非齐次线性微分方程的时候，是分成各种情况，然后按照各种情况给出解的形式，高数书中都有讲到，这里不再赘述。可参考链接。这种机械记忆太困难了，然后我找找找就找到了求解该方程的一般方法——常数变易法。常数变易法应该是个很熟悉的名词，在高数课本上推导一阶非齐次常系数线性微分方程的求解公式的时候就是用的该方法。在一般的高阶非齐次线性微分方程上，该方法同样适用。一阶非齐次线性微分方程对于一阶齐次线性微分方程$y’ + p(x)y = 0$，可以直接通过分离变量，直接积分得到通解：$$\begin{aligned}\frac{dy}{dx} + p(x)y = 0&amp;\Rightarrow \frac{dy}{y}=-p(x)dx\\&amp;\Rightarrow \ln |y| =\int-p(x)dx\\&amp;\Rightarrow y = C_0 e^{\int-p(x)dx}\end{aligned}$$而求解一阶非齐次线性微分方程$y’ + p(x)y = q(x)$，我们知道非齐次线性微分方程的通解=齐次方程的通解+非齐次方程的一个特解，我们只需将齐次方程通解的常系数$C_0$改成关于$x$的函数$C(x)$来求解非齐次方程的一个特解。设非齐次方程的一个特解为$y$，齐次方程的通解为$y_c$，非齐次方程的一个特解为$y_p$，有：$$y=y_c+y_p,,\quad y_c = C_0 e^{\int-p(x)dx},\quad y_p=C(x)e^{\int-p(x)dx}$$下面计算$C(x)$:将$y_p=C(x)e^{\int-p(x)dx}$代入微分方程$y’ + p(x)y = q(x)$有:$$\begin{align}C ^ { \prime } &amp;( x ) e ^ { - \int p ( x ) d x } - C ( x ) p ( x ) e ^ { - \int p ( x ) d x } + p ( x ) C ( x ) e ^ { - \int p ( x ) d x } = q ( x )\\ \Rightarrow &amp;C ^ { \prime } ( x ) = e ^ { \int p ( x ) d x } q ( x )\\ \Rightarrow &amp;C ( x ) = \int e ^ { \int p ( x ) d x } q ( x ) dx + C_1\\\end{align}$$$$\therefore y=y_c+y_p= e ^ { - \int p ( x ) d x }\Big(C _ { 0 } + \int q ( x ) e ^ { \int p ( x ) d x } d x\Big)$$二阶非齐次线性微分方程二阶齐次线性微分方程的通解形式为$y=C_1 u_1(x)+C_2 u_2(x)$，这里不赘述具体形式。和一阶非齐次方程求解一样的过程，我们使用常数变易法求二阶非齐次方程$y’’+p(x)y’+q(x)y=f(x)$的一个特解。令$y_p=A(x) u_1(x)+B(x) u_2(x)$，注意到这里有两个未知量$A(x),B(x)$，需要两个方程才能求解出，注意到对于齐次方程$A(x),B(x)$均为常数，所以我们添加另一个条件为$0=A’(x) u_1(x)+B’(x) u_2(x)$。将$y_p=A(x) u_1(x)+B(x) u_2(x)$代入微分方程有：$$\begin{align}y’&amp;=A’(x) u_1(x)+B’(x) u_2(x)+A(x) u_1’(x)+B(x)u_2’(x)\\&amp;=A(x) u_1’(x)+B(x)u_2’(x)\\y’’&amp;=A’(x) u_1’(x)+B’(x)u_2’(x)+A(x) u_1’’(x)+B(x)u_2’’(x)\end{align}$$$$\begin{align}\therefore y’’+py’+qy&amp;=A ( x ) (u _ { 1 }’’ +pu _ { 1 }’ +qu _ { 1 }) + B ( x ) (u _ { 2 }’’ +pu _ { 2 }’ +qu _ { 2 }) \\&amp;\quad+ A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )\\&amp;=A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )\\&amp;=f(x)\end{align}$$$\therefore$我们得到$$\begin{aligned}A ^ { \prime } ( x ) u _ { 1 } ( x ) + B ^ { \prime } ( x ) u _ { 2 } (x)&amp;=0\\A ^ { \prime } ( x ) u _ { 1 } ^ { \prime } ( x ) + B ^ { \prime } ( x ) u _ { 2 } ^ { \prime } ( x )&amp;=f(x)\end{aligned}$$解得：$$A’(x)=-\frac{1}{W}u_2(x)f(x),\, B’(x)=\frac{1}{W}u_1(x)f(x)$$即：$$A(x)=\int_0^x-\frac{1}{W}u_2(t)f(t)dt+C_1,\, B(x)=\int_0^x\frac{1}{W}u_1(t)f(t)dt+C_2$$其中$W$表示朗斯基行列式：$$W(x)=\left|\begin{array}{cc}u_1(x) &amp; u_2(x) \\u_1’(x) &amp; u_2’(x)\end{array}\right| $$$$\therefore y=C_1 u_1(x)+C_2u_2(x)+\int_0^x\frac{u_1(t)u_2(x)-u_2(t)u_1(x)}{W}f(t)dt$$非齐次微分方程解的物理意义设某个线性系统满足线性微分方程$\frac{d^2 x}{dt^2}+w^2x=f$，比如受驱弹簧谐振子。第一项表示谐振子的加速度，第二项表示弹簧拉伸的张力，右项表示单位质量受作用的外力。我们考虑某$\tau$时刻到$\tau+d \tau$时刻的情况，外力从$\tau$时刻开始作用到$\tau+d \tau$时刻结束。在这个极短的时间里，谐振子没有来得及产生位移，所以有：$$x^{(\tau)}|_{t=\tau+d \tau}=0$$而根据冲量定理有，单位质量谐振子动量的变化等于该时间间隔内外力的冲量，有:$$x_t^{(\tau)}|_{t=\tau+d \tau}-x_t^{(\tau)}|_{t=\tau}=f(\tau) d \tau$$注意到在$\tau $外力刚开始作用，没有使动量(速度)产生变化，所以$x_t^{(\tau)}|_{t=\tau}=0$,所以有：$$x_t^{(\tau)}|_{t=\tau+d \tau}=f(\tau) d \tau$$综上对于二阶非齐次线性系统$\frac{d^2 x}{dt^2}+w^2x=f$的求解，可以转化为求解齐次方程，满足：$$\frac{d^2 x^{(\tau)}}{dt^2}+w^2x^{(\tau)}=0,\,x^{(\tau)}(\tau+d\tau)=0,\,\frac{dx^{(\tau)}}{dt}{\Bigg|}_{\tau+d\tau}=f(\tau)d\tau$$记$x^{(\tau)}(t)=u(t,\tau)d\tau$,则:$$x(t)=\int_0^t u(t,\tau)d\tau$$其中$u(t,\tau)$满足：$$\frac{d^2 u}{dt^2}+w^2u=0,\,u(\tau)=0,\,u’(\tau)=f(\tau)$$该公式称为冲量定理。冲量定理在求解线性系统中有广泛应用，无论是常微分方程还是偏微分方程。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>常微分方程</tag>
        <tag>数学物理方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求解线性方程组的迭代法]]></title>
    <url>%2F2018%2F11%2F06%2F%E8%BF%AD%E4%BB%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一般迭代法引言对于一般的线性方程组直接求解有高斯消去法，对称矩阵的Cholesky分解，三对角矩阵的Thomas算法。而计算过程中经常会遇到稀疏矩阵（矩阵的零元素远多于非零元素），使用高斯消去会将零元素变为非零元素，增加不必要的计算次数。而迭代法是一种求解线性方程组系数矩阵为稀疏矩阵时的高效算法。通过将线性方程组$$\boldsymbol{Ax}=\boldsymbol{b}$$等价改写成$$\boldsymbol{x}=\boldsymbol{Bx}+\boldsymbol{f}$$便可得到迭代法：$$\boldsymbol{x}^{(k+1)}=\boldsymbol{B}\boldsymbol{x}^{(k)}+\boldsymbol{f}$$定理：迭代法$$\boldsymbol{x}^{(k+1)}=\boldsymbol{B}\boldsymbol{x}^{(k)}+\boldsymbol{f}$$对任意初始点$\boldsymbol{x}^{(0)}$和$\boldsymbol{f}$均收敛的充要条件是$\rho(\boldsymbol{B})&lt;1$.雅可比(Jacobi)迭代设一般形式的线性方程组如下：$$a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1,\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\\cdots\\a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n$$将上述线性方程组作简单调整就可以得到Jacobi迭代公式了，将上述线性方程组写成如下形式：$$\begin{align}x_1&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2-\cdots-a_{1,n}x_n)，\\x_2&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1-a_{2,3}x_3\cdots-a_{2,n}x_n),\\\cdots\\x_n&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1-a_{n,2}x_2-\cdots-a_{n,n-1}x_{n-1})\end{align}$$上述线性方程组左边视为新一时刻的值，那么这个新值就可以利用右边的旧值计算得到，于是得到的迭代格式即：$$x_{i}^{(k+1)}=x_{i}^{(k)}+\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{n}a_{ij}x_{j}^{(k)}\Big)$$上式即为Jacobi迭代法。设$$\begin{align}\boldsymbol{D}&amp;=\boldsymbol{diag}(a_{11},a_{22},\cdots,a_{nn}),\\\boldsymbol{L}&amp;=\begin{bmatrix}0 &amp; &amp; &amp; &amp; &amp;0\\-a_{21} &amp; 0 &amp; &amp; &amp; &amp;\\\vdots &amp; \ddots &amp; \ddots &amp; &amp; &amp;\\-a_{j1} &amp; \cdots &amp; -a_{j,j-1} &amp; 0&amp; &amp;\\\vdots &amp; &amp; \vdots &amp; \ddots &amp; \ddots &amp; \\-a_{n1} &amp; \cdots &amp; -a_{n,j-1} &amp; \cdots &amp; -a_{n,n-1} &amp; 0\end{bmatrix},\\\boldsymbol{U}&amp;=\begin{bmatrix}0 &amp; -a_{12} &amp; \cdots &amp; -a_{1j} &amp; \cdots &amp; -a_{1n}\\&amp; 0 &amp; \ddots &amp;\vdots &amp; &amp;\vdots\\&amp; &amp; \ddots &amp; -a_{j-1,j} &amp; \cdots &amp; -a_{j-1,n}\\&amp; &amp; &amp; \ddots &amp; \ddots &amp; \vdots\\&amp; &amp; &amp; &amp; 0 &amp; -a_{n-1,n} \\0 &amp; &amp; &amp; &amp; &amp; 0\end{bmatrix},\end{align}$$则:$$\boldsymbol{A}=\boldsymbol{D}-\boldsymbol{L}-\boldsymbol{U}\\\boldsymbol{D}\boldsymbol{x}=(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}+\boldsymbol{b}\\\boldsymbol{x}=\boldsymbol{D}^{-1}(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}+\boldsymbol{D}^{-1}\boldsymbol{b}$$所以矩阵形式的Jacobi迭代即为:$$\boldsymbol{x}^{(k+1)}=\boldsymbol{D}^{-1}(\boldsymbol{L}+\boldsymbol{U})\boldsymbol{x}^{(k)}+\boldsymbol{D}^{-1}\boldsymbol{b}$$高斯塞德尔(Gauss–Seidel)迭代注意到Jacobi迭代计算每一个方程时都会产生新值，而这个新值就可以放到下一个方程里代替旧值计算，即原式：$$\begin{align}x_1^{(k+1)}&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2^{(k)}-\cdots-a_{1,n}x_n^{(k)})，\\x_2^{(k+1)}&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1^{(k)}-a_{2,3}x_3^{(k)}\cdots-a_{2,n}x_n^{(k)}),\\\cdots\\x_n^{(k+1)}&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1^{(k)}-a_{n,2}x_2^{(k)}-\cdots-a_{n,n-1}x_{n-1}^{(k)})\end{align}$$修改为：$$\begin{align}x_1^{(k+1)}&amp;=\frac{1}{a_{1,1}}(b_1-a_{1,2}x_2^{(k)}-\cdots-a_{1,n}x_n^{(k)})，\\x_2^{(k+1)}&amp;=\frac{1}{a_{2,2}}(b_2-a_{2,1}x_1^{(k+1)}-a_{2,3}x_3^{(k)}\cdots-a_{2,n}x_n^{(k)}),\\\cdots\\x_{n-1}^{(k+1)}&amp;=\frac{1}{a_{n-1,n-1}}(b_{n-1}-a_{n-1,1}x_1^{(k+1)}-a_{n-1,2}x_2^{(k+1)}-\cdots-a_{n-1,n-2}x_{n-2}^{(k+1)}-a_{n-1,n}x_{n}^{(k)})\\x_n^{(k+1)}&amp;=\frac{1}{a_{n,n}}(b_n-a_{n,1}x_1^{(k+1)}-a_{n,2}x_2^{(k+1)}-\cdots-a_{n,n-1}x_{n-1}^{(k+1)})\end{align}$$即：$$x_{i}^{(k+1)}=\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$写成矩阵形式:$$\begin{align}\begin{pmatrix}a_{11} &amp; &amp; &amp;\\&amp; a_{22} &amp; &amp; \\&amp; &amp; \ddots &amp; \\&amp; &amp; &amp; a_{nn}\end{pmatrix}\begin{pmatrix}x_{1}^{(k+1)}\\x_{2}^{(k+1)}\\\vdots\\x_{n}^{(k+1)}\end{pmatrix}&amp;=\begin{pmatrix}0 &amp; &amp; &amp;\\-a_{21} &amp; 0 &amp; &amp; \\\vdots &amp; \vdots &amp; \ddots &amp; \\-a_{n1} &amp; -a_{n2} &amp;\cdots &amp; 0\end{pmatrix}\begin{pmatrix}x_{1}^{(k+1)}\\x_{2}^{(k+1)}\\\vdots\\x_{n}^{(k+1)}\end{pmatrix}\\&amp;+\begin{pmatrix}0 &amp; -a_{12} &amp; &amp; -a_{1n}\\&amp; 0 &amp; \cdots &amp; -a_{2n}\\&amp; &amp; \ddots &amp; \vdots \\&amp; &amp; &amp; 0\end{pmatrix}\begin{pmatrix}x_{1}^{(k)}\\x_{2}^{(k)}\\\vdots\\x_{n}^{(k)}\end{pmatrix}+\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\end{pmatrix}\end{align}$$即：$$\boldsymbol{D}\boldsymbol{x}^{(k+1)}=\boldsymbol{L}\boldsymbol{x}^{(k+1)}+\boldsymbol{U}\boldsymbol{x}^{(k)}+\boldsymbol{b}\\\boldsymbol{D}\boldsymbol{x}^{(k+1)}-\boldsymbol{L}\boldsymbol{x}^{(k+1)}=\boldsymbol{U}\boldsymbol{x}^{(k)}+\boldsymbol{b}\\\boldsymbol{x}^{(k+1)}=(\boldsymbol{D}-\boldsymbol{L})^{-1}\boldsymbol{U}\boldsymbol{x}^{(k)}+(\boldsymbol{D}-\boldsymbol{L})^{-1}\boldsymbol{b}$$连续过松弛(SOR)高斯塞德尔迭代格式如下：$$x_{i}^{(k+1)}=\frac{1}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$我们考虑上式右端和$x_i^{(k)}$的线性组合形式来计算$x_i^{(k+1)}$得到如下格式：$$x_{i}^{(k+1)}=(1-\omega)x_{i}^{(k)}+\frac{\omega}{a_{ii}}\Big(b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)}\Big)$$以上即为超松弛格式(SOR)，其中$\omega$为松弛系数，调整松弛系数来加快迭代计算速度，当$\omega=1$时，即为高斯塞德尔迭代。代码见:https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/iterativeMethod.cpp一种特殊的迭代求解线性方程组的方法引言我们要求解的线性方程组为$Ax=b$，注意到函数$G(x)=\frac{1}{2}x^T Ax-x^T b$达到极小值时满足$\frac{d G}{dx}=Ax-b=0$，所以我们将求解线性方程组转换成求解函数$G(x)=\frac{1}{2}x^T Ax-x^T b$的极小值。为了保证解的唯一性，我们要求系数矩阵$A$是正定且对称的，这样函数$G(x)$为凸函数，其局部最小值即为全局极小值且唯一。综上，我们可以使用一些求解函数最小值的算法求解线性方程组$Ax=b$，下面只介绍一种算法：共轭梯度法。共轭梯度法共轭 共轭可以理解成一种推广的向量正交，它指对于正定对称矩阵$A$，如果向量$u,v$满足$u^T Av=0$，则称向量$u,v$关于矩阵$A$共轭，显然向量$u,v$正交即向量$u,v$关于矩阵$I$共轭。求解函数$G(x)$极小值过程为：选定初值$x_{0}$，初始搜索方向$s_{0}$，一般选为$s_{0}=-\nabla G(x_{0})$下一步迭代点由式$x_{k+1}=x_{k}+\lambda_{k} s_{k}$给出，其中$\lambda_{k}$由$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$计算得到计算下一步搜索方向$s_{k+1}$重复上述过程直到满足收敛条件，如$\nabla G(x_k)=0$.上述中$\lambda_{k}$表示第$k$步沿方向$s_{k}$的搜索步长，$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$保证找到的步长使得函数减小最多。共轭梯度法 就是选定一组共轭的搜索方向，这种选取方式能保证迭代最多$n$步就能收敛最小值。首先 我们确定$\lambda_{k}$，$\lambda_{k}$由$\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}=0$确定。所以：$$\begin{align}\frac{d G(x_{k}+\lambda_{k} s_{k})}{d \lambda_{k}}&amp;=\nabla G(x_{k}+\lambda_{k} s_{(k)})^T s_{k}\\&amp;=[A(x_{k}+\lambda_{k} s_{k})]^T s_{k} -b^T s_{k}\\&amp;=x_{k}^T As_{k}+\lambda_{k}s_{k}^T A s_{k}-b^T s_{k}\\&amp;=0\\\Longrightarrow \lambda_k&amp;= \frac{(b^T-x_k^T A)s_k}{s_k^T A s_k}=\frac{s_k^T( b-Ax_k)}{s_k^T A s_k}\end{align}$$然后 我们生成共轭方向作为每次迭代的搜索方向。我们可以将每次迭代计算得到的负梯度方向$=\nabla G(x)$作为初始方向，然后用类似施密特正交化的方式生成共轭方向。每次迭代计算的负梯度为：$-\nabla G(x_k)=b-Ax_k=r_k$，对于线性方程组$Ax=b$来说，$b-Ax_k$为每步计算的残差，所以这里设为$r_k$。类似施密特正交化我们得到共轭方向：$$\begin{align}s_0&amp;=r_0=b-Ax_0,\\s_k&amp;=r_k-\sum_{i&lt;k}\frac{s_i^T A r_k}{s_i^T A s_i}s_i\end{align}$$显然$s_j,\,(j=0,1,2…k)$相互关于$A$共轭，归纳显然。最后 证明共轭梯度法最多$n$步收敛$n$步收敛只需要证明$\nabla G(x_n)=0$即可。$$\begin{align}\nabla G(x_n)&amp;=Ax_n-b\\&amp;=A(x_{n-1}+\lambda_{n-1}s_{n-1})-b\\&amp;=\nabla G(x_{n-1})+\lambda_{n-1}As_{n-1}\\&amp;=\nabla G(x_{j})+\sum\limits_{i=j}^{n-1}\lambda_i A s_i\end{align}$$对上式右乘$s_j,\, j=0,1,2,…,n-1$$$\begin{align}\therefore \nabla G(x_n)^T s_j&amp;=\nabla G(x_{j})^T s_j+\sum\limits_{i=j}^{n-1}\lambda_i s_i^T A s_j\\&amp;=\nabla G(x_{j})^T s_j+\lambda_j s_j^T A s_j\\&amp;=(\nabla G(x_{j})+\lambda_j A s_j)^Ts_j\\&amp;=\nabla G(x_{j+1})^T s_j\end{align}$$注意到：$$\frac{d G(x_j+\lambda s_j)}{d \lambda}=\nabla G(x_{j+1})^T s_j=0$$有：$$\nabla G(x_n)^T s_j=\nabla G(x_{j+1})^T s_j=0,\, j=0,1,2,…,n-1$$对于一组$A$共轭向量$s_j,\, j=0,1,2,…,n-1$,$\nabla G(x_n)^T s_j=0$,显然$\nabla G(x_n)=0$,所以共轭梯度法最多$n$步收敛。程序计算步骤：$$\begin{align} &amp;r_0 = b - Ax_0\\&amp;\text{如果} r_0\text{足够小, 就返回 } x_0\text{ 作为结果}\\&amp;s_0=r_0\\&amp;k=0\\&amp;\text{循环：}\\&amp;\qquad \alpha_k=\frac {r_k^T r_k}{s_k^T As_k}\\&amp;\qquad x_{k+1}= x_k+\alpha_k s_k\\&amp;\qquad r_{k+1}= r_k-\alpha_k As_k\\&amp;\qquad \text{如果} r_{k+1}\text{ 足够小, 就跳出循环}\\&amp;\qquad \beta_k={\frac { r_{k+1}^T r_{k+1}}{ r_k^T r_k}}\\&amp;\qquad s_{k+1} = r_{k+1}+\beta_k s_k\\&amp;\qquad k=k+1\\&amp;\text{返回 } x_{k+1}\text{作为结果}\end{align}$$代码见:https://github.com/Love-Chrissie/numerical-computation/blob/master/%E8%BF%AD%E4%BB%A3%E6%B3%95/ConjugateGradient.py]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵与数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QR分解之Householder变换]]></title>
    <url>%2F2018%2F10%2F19%2FQR%E5%88%86%E8%A7%A3%E4%B9%8BHouseholder%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[定义Householder矩阵如下：$$\boldsymbol{H}(\boldsymbol{w})=\boldsymbol{I}-\frac{2}{\boldsymbol{w}^T \boldsymbol{w}} \boldsymbol{w} \boldsymbol{w}^T$$显然该矩阵具有如下性质：$\boldsymbol{H}^T=\boldsymbol{H}$，即$\boldsymbol{H}$为对称阵；$\boldsymbol{H}^T\boldsymbol{H}=\boldsymbol{I}$，即$\boldsymbol{H}$为正交阵；如果$\boldsymbol{H}\boldsymbol{x}=\boldsymbol{y}$，则$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$；反之，对于任意两个向量$\boldsymbol{x},\boldsymbol{y}\in \mathbb{R}^n$，若$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$，且$\vec{x}\neq\vec{y}$，则必存在Householder矩阵$\boldsymbol{H}$，使得$\boldsymbol{y}=\boldsymbol{H}\boldsymbol{x}$；设$\vec{x}=(x_1,x_2,\cdots,x_n)^T\in \mathbb{R}^n$且$\vec{x}\neq\vec{0}$，取$\vec{w}=\vec{x}\pm\parallel \vec{x}\parallel_2 \vec{e}_1$，则$\boldsymbol{H}(\boldsymbol{w})\boldsymbol{x}=\boldsymbol{H}(\boldsymbol{x}\pm\parallel \boldsymbol{x}\parallel_2 \boldsymbol{e}_1)\vec{x}=\pm\parallel \vec{x}\parallel_2 \vec{e}_1=\pm\parallel \vec{x}\parallel_2 (1,0,\cdots,0)^T$.证明：(1),(2)显然，证明(3)显然有：$$\parallel \boldsymbol{y}\parallel_2^2=\boldsymbol{y}^T\boldsymbol{y}=(\boldsymbol{H}\boldsymbol{x})^T(\boldsymbol{H}\boldsymbol{x})=\boldsymbol{x}^T(\boldsymbol{H}^T\boldsymbol{H})\boldsymbol{x}=\boldsymbol{x}^T\boldsymbol{x}=\parallel\boldsymbol{x}\parallel_2^2$$反之，若$\parallel \vec{y}\parallel_2=\parallel \vec{x}\parallel_2$，且$\vec{x}\neq\vec{y}$,令$\boldsymbol{w}=\boldsymbol{x}-\boldsymbol{y}$,有：$$\parallel\boldsymbol{w}\parallel_2^2=(\boldsymbol{x}-\boldsymbol{y})^T(\boldsymbol{x}-\boldsymbol{y})=(2\boldsymbol{x}-(\boldsymbol{x}+\boldsymbol{y}))^T(\boldsymbol{x}-\boldsymbol{y})=2\boldsymbol{x}^T(\boldsymbol{x}-\boldsymbol{y})$$$$\begin{align}\boldsymbol{H}(\boldsymbol{w})\boldsymbol{x}&amp;=(\boldsymbol{I}-\frac{2}{\boldsymbol{w}^T \boldsymbol{w}} \boldsymbol{w} \boldsymbol{w}^T)\boldsymbol{x}=(\boldsymbol{I}-\frac{2}{\parallel\boldsymbol{x}-\boldsymbol{y}\parallel_2^2} (\boldsymbol{x}-\boldsymbol{y}) (\boldsymbol{x}-\boldsymbol{y})^T)\boldsymbol{x}\\&amp;=\boldsymbol{x}-\frac{2(\boldsymbol{x}-\boldsymbol{y})^T\boldsymbol{x}}{\parallel\boldsymbol{x}-\boldsymbol{y}\parallel_2^2}(\boldsymbol{x}-\boldsymbol{y})=\boldsymbol{x}-(\boldsymbol{x}-\boldsymbol{y})=\boldsymbol{y}\end{align}$$性质(4)由性质(3)自然得出。$m\times n$阶矩阵三角化过程记$$A_{m\times n}^{(1)}=A_{m\times n}=\begin{bmatrix}a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\\a_{21}^{(1)} &amp; a_{22}^{(1)} &amp; \cdots &amp; a_{2n}^{(1)}\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\a_{m1}^{(1)} &amp; a_{m2}^{(1)} &amp; \cdots &amp; a_{mn}^{(1)}\end{bmatrix}$$取正交矩阵$Q_1=H_1$(依性质4取Householder矩阵)，这里$H_1$是将$m$维向量$(a_{11}^{(1)}, a_{21}^{(1)},\cdots,a_{m1}^{(1)})^T$变换为$m$维向量$(k_1, 0,\cdots,0)^T$的Householder变换矩阵$$H_1=I_m-\alpha_1 \boldsymbol{u}_1 \boldsymbol{u}_1^T$$这里$$|k_1|^2=\boldsymbol{x}^T \boldsymbol{x},\boldsymbol{u}=\boldsymbol{x-k_1\boldsymbol{e}_1},\alpha=\frac{1}{k_1(k_1-\boldsymbol{e}_1^T \boldsymbol{x})}=\frac{2}{\boldsymbol{u}^T\boldsymbol{u}}$$得到$$A_{m\times n}^{(2)}=Q_1 A_{m\times n}^{(1)}=\begin{bmatrix}k_1 &amp; a_{12}^{(2)} &amp; \cdots &amp; a_{1n}^{(2)}\\0 &amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; a_{m2}^{(2)} &amp; \cdots &amp; a_{mn}^{(2)}\end{bmatrix}$$这里$$\begin{bmatrix}a_{1,j}^{(2)}\\a_{2,j}^{(2)}\\ \vdots \\ a_{m,j}^{(2)}\end{bmatrix}=H_1\begin{bmatrix}a_{1,j}^{(1)}\\a_{2,j}^{(1)}\\ \vdots \\ a_{mj}^{(1)}\end{bmatrix}=\begin{bmatrix}a_{1,j}^{(1)}\\a_{2,j}^{(1)}\\ \vdots \\ a_{mj}^{(1)}\end{bmatrix}-\alpha_1\sum\limits_{l=1}^{m}u_{1l}a_{l,j}^{(1)}\boldsymbol{u}_1\quad\,j=2,3,\cdots,n$$一般第$k$步取正交矩阵$Q_k$$$Q_k=\begin{bmatrix}I_{k-1} &amp; \quad \\ \quad &amp; H_k\end{bmatrix}$$这里$H_k$是将$m-k+1$维向量$(a_{k,k}^{(k)},a_{k+1,k}^{(k)},\cdots,a_{m,k}^{(k)})^T$变换为$m-k+1$维向量$(k_k,0,\cdots,0)^T$的Householder矩阵$$H_k=I_{m-k+1}-\alpha_k \boldsymbol{u}_k \boldsymbol{u}_k^T$$这里$\boldsymbol{u}_k$为$m-k+1$维向量，这时$$A_{m\times n}^{(k+1)}=Q_1 A_{m\times n}^{(k)}=\begin{bmatrix}k_1 &amp; a_{1,2}^{(2)} &amp; \cdots &amp; a_{1,k}^{(2)} &amp; a_{1,k+1}^{(2)} &amp; \cdots &amp; a_{1,n}^{(2)}\\ &amp; k_2 &amp; \cdots &amp; a_{2,k}^{(3)} &amp; a_{2,k+1}^{(3)} &amp; \cdots &amp; a_{2,n}^{(3)}\\&amp; &amp; \ddots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots\\ &amp; &amp; &amp; k_k &amp; a_{k,k+1}^{(k+1)} &amp; \cdots &amp; a_{k,n}^{(k+1)}\\&amp; &amp; &amp; &amp; a_{k+1,k+1}^{(k+1)} &amp; \cdots &amp; a_{k+1,n}^{(k+1)}\\&amp; &amp; &amp; &amp; \cdots &amp; \cdots &amp; \cdots\\&amp; &amp; &amp; &amp; a_{m,k+1}^{(k+1)} &amp; \cdots &amp; a_{m,n}^{(k+1)} \end{bmatrix}$$其中$$\begin{bmatrix}a_{k,j}^{(k+1)}\\a_{k+1,j}^{(k+1)}\\ \vdots \\ a_{m,j}^{(k+1)}\end{bmatrix}=H_k\begin{bmatrix}a_{k,j}^{(k)}\\a_{k+1,j}^{(k)}\\ \vdots \\ a_{mj}^{(k)}\end{bmatrix}=\begin{bmatrix}a_{k,j}^{(k)}\\a_{k+1,j}^{(k)}\\ \vdots \\ a_{mj}^{(k)}\end{bmatrix}-\alpha_k\sum\limits_{l=1}^{m-k+1}u_{kl}a_{k+l-1,j}^{(k)}\boldsymbol{u}_k\quad\,j=k+1,\cdots,n,\text{其他元素不变}$$记$s=\min(m-1,n)$则当$k=s$时即可完成矩阵的三角化过程，即$$QA=Q_s Q_{s-1} \cdots Q_1 A=R$$由于$Q$为正交矩阵，所以$$A=Q^T R$$$QR$分解的python代码如下1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npdef householder(A, y): row = np.shape(A)[0] col = np.shape(A)[1] u = np.zeros(row) for i in range(col): # 计算第i列模 aa = 0.0 for l in range(i, row): aa += A[l, i]*A[l, i] aa = np.sqrt(aa) # 防止分母过小 if A[i, i] &gt; 0.0 : ki = -aa else: ki = aa alpha = 1.0/(ki*(ki-A[i, i])) u[i] = A[i, i] - ki A[i, i] = ki for l in range(i+1, row): u[l] = A[l, i] A[l, i] = 0.0 for j in range(i+1, col): aa = 0.0 for l in range(i, row): aa += u[l] * A[l, j] aa = alpha * aa for l in range(i, row): A[l, j] -= aa * u[l] aa = 0.0 for l in range(i, row): aa += u[l] * y[l] aa *= alpha for l in range(i, row): y[l] -= aa * u[l] print("Matrix HA, and Hy:") for i in range(row): for j in range(col): print("&#123;:14.8f&#125;".format(A[i, j]), end='') print(" |&#123;:14.8f&#125;".format(y[i]))]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵与数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道三角函数无穷积分两道数论]]></title>
    <url>%2F2018%2F10%2F15%2F%E4%B8%80%E9%81%93%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E6%97%A0%E7%A9%B7%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[积分证明：$\int_{0}^{\infty}\cos{x^p}dx=\frac{\Gamma(\frac{1}{p})\cos {\frac{\pi}{2p}}}{p}$过程：$$\begin{align}\int_{0}^{\infty}\cos{x^p}dx &amp;=\frac{1}{p}\int_{0}^{\infty}\frac{\cos u}{u^{1-\frac{1}{u}}}du=\frac{1}{p}\int_0^{\infty}z^{-\frac{1}{p}}e^{-zu}dz\,\cdot\int_0^{\infty}\cos udu\\&amp;=\frac{1}{p\Gamma(1-\frac{1}{p})}\int_0^{\infty}z^{-\frac{1}{p}}dz\int_0^{\infty}\cos u e^{-zu}du\\&amp;=\frac{1}{p\Gamma(1-\frac{1}{p})}\int_0^{\infty}\frac{z^{1-\frac{1}{p}}}{z^2+1}dz,\quad\text{let }t=z^2\\&amp;=\frac{1}{2p\Gamma(1-\frac{1}{p})}\int_0^{\infty}\frac{t^{-\frac{1}{2p}}}{t+1}dt=\frac{1}{2p\Gamma(1-\frac{1}{p})}B(1-\frac{1}{2p},\,\frac{1}{2p})\\&amp;=\frac{\sin\big[(1-\frac{1}{p})\pi\big]\Gamma(\frac{1}{p})}{2p\pi}\cdot\frac{\pi}{\sin\big[(1-\frac{1}{2p})\pi\big]}\\&amp;=\frac{\Gamma(\frac{1}{p})\cos {\frac{\pi}{2p}}}{p}\end{align}$$其中利用到了:$$\Gamma(x) = \int_0^{\infty}t^{x-1}e^{-t}dt,\\\frac{1}{x^s}=\frac{1}{\Gamma(s)}\int_0^{\infty}z^{s-1}e^{-xz}dz,\\\text{余元公式:}\,\Gamma(x)\Gamma(1-x)=\frac{\pi}{\sin{\pi x}},\\\beta \text{函数与}\Gamma\text{函数关系：}\, B(x, y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}$$数论证明$1+\frac{1}{2}+\cdots+\frac{1}{n}$不是整数，其中$n$为大于1的整数。若素数$p\equiv 3(\, mod\,4\,)$,那么素数$p$不能表示成两整数的平方和。证明：1:$\text{设}1+\frac{1}{2}+\cdots+\frac{1}{n}=k$为整数，两边乘以$n$的阶乘那么$n!+\frac{n!}{2}+\cdots+\frac{n!}{n}=kn!$.设$p$是小于$n$的最大素数，那么右边$kn!$能被$p$整除，而左边$n!+\frac{n!}{2}+\cdots+\frac{n!}{p}+\cdots+\frac{n!}{n}$的每一项，很明显除了$\frac{n!}{p}$不能被$p$整除外，都能被$p$整除，所以左边不能被$p$整除。矛盾，故$1+\frac{1}{2}+\cdots+\frac{1}{n}$不是整数。2:由于$p$是素数，且两个奇数平方相加为偶数，两偶数平方相加为也为偶数，所以必然有$p=(2n)^2+(2n+1)^2$,那么$p \equiv (2n)^2+(2n+1)^2 \equiv 1(mod 4)$，矛盾，故素数$p$不能表示成两整数的平方和。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>无穷积分</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正定矩阵的cholesky分解]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5%E7%9A%84cholesky%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[正定矩阵的cholesky分解由于正定矩阵的主子式均大于零，可得正定矩阵的顺序主子式均大于零，所以正定矩阵$\boldsymbol A$有唯一的$\boldsymbol{LDU}$分解，即：$$\boldsymbol A = \boldsymbol{LDU}$$这里$\boldsymbol L$为单位下三角矩阵，$\boldsymbol U$为单位上三角矩阵，$\boldsymbol D$为对角矩阵。又$\boldsymbol A$是对称矩阵，故：$$\boldsymbol A = \boldsymbol A^T=(\boldsymbol{LDU})^T=\boldsymbol U^T \boldsymbol D \boldsymbol L^T$$根据$\boldsymbol{LDU}$分解的唯一性得$$\boldsymbol U=\boldsymbol L^T$$故正定矩阵$\boldsymbol A$有分解式$$\boldsymbol A = \boldsymbol L \boldsymbol D \boldsymbol L^T$$这里$\boldsymbol L$的对角元素皆为1.记$$\boldsymbol D = diag(d_1,d_2,\cdots,d_n)$$由$\boldsymbol A$的正定性可得$$d_i&gt;0,i=1,2,\cdots,n$$若记$$D^{\frac{1}{2}}=diag(\sqrt{d_1},\sqrt{d_2},\cdots,\sqrt{d_n})$$则$$\boldsymbol A = \boldsymbol L\boldsymbol D^{\frac{1}{2}}\boldsymbol D^{\frac{1}{2}}\boldsymbol L^T=(\boldsymbol L\boldsymbol D^{\frac{1}{2}})(\boldsymbol L\boldsymbol D^{\frac{1}{2}})^T=\widetilde{\boldsymbol L} \widetilde{\boldsymbol L}^T$$这里$\widetilde{\boldsymbol L}=\boldsymbol L \boldsymbol D^{\frac{1}{2}}$是下三角矩阵，其对角元素皆为正数，则这种分解也是唯一的。称之为正定矩阵的Cholesky分解。计算公式由$$\boldsymbol A = \begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{pmatrix}=\begin{pmatrix}l_{11} &amp; &amp; &amp; \\l_{21} &amp; l_{22} &amp; &amp; \\\\vdots &amp; \vdots &amp; \ddots &amp; \\\l_{n1} &amp; l_{n2} &amp; \cdots &amp; l_{nn}\end{pmatrix}\begin{pmatrix}l_{11} &amp; l_{21} &amp; \cdots &amp; l_{n1}\\&amp; l_{22} &amp; \cdots &amp; l_{n2}\\\&amp; &amp; \ddots &amp; \vdots \\\&amp; &amp; &amp; l_{nn}\end{pmatrix}=\boldsymbol L \boldsymbol L^T$$矩阵对应每项相等可以得到矩阵$\boldsymbol L$的各项计算公式：$$a_{ik}=\sum\limits_{s=1}^{k-1}l_{is}l_{ks}+l_{kk}^2$$所以：$$l_{kk}=\sqrt{a_{kk}-\sum\limits_{s=1}^{k-1}l_{ks}^2}\\l_{ik}=\frac{a_{ik}-\sum\limits_{s=1}^{k-1}l_{is}l_{ks}}{l_{kk}},\quad i=k+1,\cdots,n$$python代码如下：12345678910111213def chollt(A): EPSILON = 1e-8 DIM = len(A) for k in range(DIM): for i in range(k, DIM): for j in range(k): A[i, k] = A[i, k] - A[i, j] * A[k, j] if np.fabs(A[k, k]) &lt; EPSILON: return 1 A[k, k] = np.math.sqrt(A[k, k]) for i in range(k+1, DIM): A[i, k] = A[i, k] / A[k, k] return 0]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵与数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一维稳态流动与扩散问题验证]]></title>
    <url>%2F2018%2F10%2F10%2F%E4%B8%80%E7%BB%B4%E7%A8%B3%E6%80%81%E6%B5%81%E5%8A%A8%E4%B8%8E%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[控制一维稳态流动与扩散问题验证考虑一段长为1m的区域，其稳态无源项的对流扩散方程如下：$$\dfrac{d}{dx}(\rho u\phi)=\dfrac{d}{dx}(\Gamma\dfrac{d\phi}{dx})$$流动还需满足连续性方程：$$\dfrac{d(\rho u)}{dx}$$积分上两式可得：$$(\rho u A\phi)_e-(\rho u A\phi)_w=\big(\Gamma A\dfrac{d\phi}{dx}\big)_e-\big(\Gamma A\dfrac{d\phi}{dx}\big)_w\\(\rho u)_e-(\rho u)_w=0$$定义两变量$F=\rho u$ 表示单位面积对流通量$D=\frac{\Gamma}{\delta x}$ 表示通过单元面的扩导所以积分的对流扩散方程可重新写为：$F_w=(\rho u)_w,D_w=\frac{\Gamma_w}{\delta x_{WP}},F_e=(\rho u)_e,D_e=\frac{\Gamma_e}{\delta x_{PE}}.$连续性方程为:$F_e-F_w=0$使用中心差分离散方程最后的形式为：$$a_P \phi_P=a_W \phi_W+a_E \phi_E,\text{其中}a_W=D_w+\frac{F_w}{2},a_E=D_e-\frac{F_e}{2},a_P=a_E+a_W+(F_e-F_w)$$本次算例解析解为：$$\frac{\phi-\phi_0}{\phi_L-\phi_0}=\frac{\exp(\frac{\rho ux}{\Gamma})-1}{\exp(\frac{\rho uL}{\Gamma})-1}$$边界条件为：$\phi_0=1$当$x=0$和$\phi_L=0$当$x=L$.对边界点，其离散方程应改为：对于第一个点，$-(a_P+a_W) \phi_P+a_E\phi_E+2a_W\phi_0=0 $对于最后一个点，$a_W \phi_W-(a_P+a_E) \phi_P=0 $三种情况验证：u=0.1 m/s,节点数为5u=2.5 m/s,节点数为5u=2.5 m/s,节点数为20得到三种图像如下：python代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python # encoding: utf-8 import numpy as npimport matplotlib.pyplot as pltu = 2.5 # 流速n=20 # 划分节点数（或者说控制体个数）L = 1.0 # 总长度rho = 1.0 # 密度Gamma = 0.1 # 扩散系数#解析解x = np.linspace(0,1,100)phi = np.array([(np.exp(rho*u*L/Gamma)-np.exp(rho*u*xx/Gamma))/(np.exp(rho*u*L/Gamma)-1) for xx in x])#数值解delta_x = L/n # 控制体边长F = rho*u # 对流通量D = Gamma/delta_x # 扩导aW=D+F/2aE=D-F/2aP=aW+aEA = -aP*np.ones(n)B = np.zeros(n)B[0] = -2*aWA[0] = A[0]-aWA[n-1] = A[n-1]-aE#Thomas算法，并同时画图#计算过程使用托马斯算法，这里由于生成的三对阵简答，没有使用通用的thomas算法，而是针对本算例进行了简化for i in range(1,n): A[i] = A[i]-aW*aE/A[i-1] B[i] = B[i]-aW*B[i-1]/A[i-1]B[n-1] = B[n-1]/A[n-1]xx = np.linspace(delta_x/2,1-delta_x/2,n)plt.scatter(xx[n-1], B[n-1], color='', marker='o', edgecolors='g', s=100, label='numerical solution')for i in range(n-2,-1,-1): B[i] = (B[i]-aE*B[i+1])/A[i] plt.scatter(xx[i], B[i], color='', marker='o', edgecolors='g', s=100)plt.scatter(0, 1, color='', marker='o', edgecolors='g', s=100) # 边界点plt.scatter(1, 0, color='', marker='o', edgecolors='g', s=100) # 边界点plt.plot(x,phi,label='analysis solution')plt.rcParams['font.sans-serif']=['SimHei']plt.xlabel(u"位置") # x轴名称plt.ylabel(u"变量") # y轴名称plt.title(u"一维稳态对流扩散问题") # 图名plt.legend()#plt.text() # 在图上自定位置处写下标记#plt.axis([0,L,0,1]) # 设定坐标轴范围plt.grid(True) # 开关网格plt.savefig("case3.png")plt.show() # 打印图像]]></content>
  </entry>
  <entry>
    <title><![CDATA[Fibonacci序列]]></title>
    <url>%2F2018%2F10%2F10%2FFibonacci%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[从Fibonacci序列谈起定义$F_0=0,\quad F_1=1,\quad F_n=F_{n-1}+F_{n-2}\quad (n&gt;1)$递归算法的$F_n$计算时间复杂度为$O(2^n)$，为指数时间。空间复杂度为$S_n=O(n)$为线性空间。改用备忘录的方式计算Fibonacci序列可以更节约时间。类似如下方式：$F_0$$F_1$$F_2$$F_3$$F_4$$F_5$011235但空间仍然是$O(n)$，如果只需要求$F_n$则有很大空间浪费。所以我们只需要保存前两项即可。$P_1=0,P_2=1,C=P_1+P_2=1$,下一次赋值结果为$P_1=1,P_2=1,C=2$,时间复杂度为$O(n)$,空间复杂度为$O(1)$。更好的方式：使用Fibonacci序列的矩阵形式$$\begin{align}\begin{pmatrix}F_{n+1}\\F_n\end{pmatrix}&amp;=\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}\begin{pmatrix}F_{n}\\F_{n-1}\end{pmatrix}\\&amp;=\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^2\begin{pmatrix}F_{n-1}\\F_{n-2}\end{pmatrix}\\&amp;\cdots\\&amp;=\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^n\begin{pmatrix}F_{1}\\F_{0}\end{pmatrix}\end{align}$$即最后结果为：$$\begin{pmatrix}F_{n+1}\\F_n\end{pmatrix}=\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^n\begin{pmatrix}F_{1}\\F_{0}\end{pmatrix}$$下面用一个简单方法处理计算$\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^n$$\text{令：}A=\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix},\text{那么}A^n=\begin{pmatrix}F_{n+1} &amp; F_n\\F_n &amp; F_{n-1}\end{pmatrix}\text{归纳易证}$$\text{所以}A^{2m}=\begin{pmatrix}F_{2m+1} &amp; F_{2m}\\F_{2m} &amp; F_{2m-1}\end{pmatrix}=A^m\cdot A^m,\quad A^m=\begin{pmatrix}F_{m+1} &amp; F_m\\F_m &amp; F_{m-1}\end{pmatrix}\\\begin{align}so:\begin{pmatrix}F_{2m+1} &amp; F_{2m}\\F_{2m} &amp; F_{2m-1}\end{pmatrix}&amp;=\begin{pmatrix}F_{m+1} &amp; F_m\\F_m &amp; F_{m-1}\end{pmatrix}\begin{pmatrix}F_{m+1} &amp; F_m\\F_m &amp; F_{m-1}\end{pmatrix}\\&amp;=\begin{pmatrix}F_{m+1}^2+F_m^2 &amp; F_{m+1}F_m+F_m F_{m-1}\\F_{m+1}F_m+F_m F_{m-1} &amp; F_{m}^2+F_{m-1}^2\end{pmatrix} \end{align}$$\Longrightarrow \begin{cases}F_{2m+1}=F_{m+1}^2+F_m^2\\F_{2m}=F_m(F_{m+1}+ F_{m-1})\end{cases}\text{得到了Fibonacci序列的另一种递推公式}$$n$为奇数，即$n=2m+1，\lfloor\frac{n}{2}\rfloor=m$$$\begin{pmatrix}F_{n+1}\\F_{n}\end{pmatrix}=\begin{pmatrix}F_{2m+2}\\F_{2m+1}\end{pmatrix}=\begin{pmatrix}(2F_{m}+F_{m+1})F_{m+1}\\F_{m}^2+F_{m+1}^2\end{pmatrix}$$n为偶数，即$n=2m，\lfloor\frac{n}{2}\rfloor=m$$$\begin{pmatrix}F_{n+1}\\F_{n}\end{pmatrix}=\begin{pmatrix}F_{2m+1}\\F_{2m}\end{pmatrix}=\begin{pmatrix}F_{m}^2+F_{m+1}^2\\(2F_{m+1}-F_{m})F_{m}\end{pmatrix}$$这里仅用第m项与第m+1项表达，计算过程中的m-1项和m+2项利用Fibonacci数列的递推公式代换掉了。所以对于$Fibonacci(n)$我们只需要计算$Fibonacci(n/2)=Fibonacci(m)$。其时间复杂度为$O(\log n)$，空间复杂度也为$O(\log n)$。python代码如下：1234567def Fibonacci(n): if n&lt;=0: return (0, 1) f_m, f_m1 = Fibonacci(n/2) if n%2: return f_m**2+f_m1**2, (2*f_m+f_m1)*f_m1 return (2*f_m1-f_m)*f_m1, f_m**2+f_m1**2]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式拟合]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[给定一个训练数据集：$$T=\begin{Bmatrix}(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\end{Bmatrix}$$其中，$x_i\in \mathbb{R}$是输入$x$的观测值，$y_i\in\mathbb{R}$是相应的输出$y$的观测值，$i=1,2,\cdots,N.$多项式拟合需要做的就是在$M$次多项式函数中选择一个对已知数据和未知数据都有很好的预测能力的函数。设$M$次多项式函数为：$$f_M(x,w)=w_0+w_1 x+w_2 x^2+\cdots+w_M x^M=\sum\limits_{j=0}^{M}w_j x^j$$式中$x$是单变量输入，$w_0,w_1,\cdots,w_M$是$M+1$个参数。选取平方损失为损失函数：$$L(w)=\frac{1}{2}\sum\limits_{i=1}^{N}\bigg(\sum\limits_{j=0}^{M}w_j x_{i}^{j}-y_i\bigg)^2$$对$w_j$求偏导并令其为$0$可得：$$\frac{\partial L}{\partial w_j}=x_1^j (\sum\limits_{j=0}^{M}w_j x_1^j -y_1)+x_2^j (\sum\limits_{j=0}^{M}w_j x_2^j -y_2)+\cdots+x_N^j (\sum\limits_{j=0}^{M}w_j x_N^j -y_N)=0\Rightarrow \\\sum\limits_{j=0}^{M}\sum\limits_{i=1}^{N}w_j x_i^j=\sum\limits_{i=1}^{N}x_i^j y_i$$对于$j=0,1,\cdots,M$可得到如下线性方程组：$$\begin{pmatrix}\sum\limits_{i=1}^{N}x_i^0 &amp; \sum\limits_{i=1}^{N}x_i^1 &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^M \\\sum\limits_{i=1}^{N}x_i^1 &amp; \sum\limits_{i=1}^{N}x_i^2 &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^{M+1} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\sum\limits_{i=1}^{N}x_i^M &amp; \sum\limits_{i=1}^{N}x_i^{M+1} &amp; \cdots &amp; \sum\limits_{i=1}^{N}x_i^{M+M}\end{pmatrix}\begin{pmatrix}w_0\\w_1\\\vdots\\w_M\end{pmatrix}=\begin{pmatrix}\sum\limits_{i=1}^{N}x_i^0 y_i \\\sum\limits_{i=1}^{N}x_i^1 y_i \\\vdots \\\sum\limits_{i=1}^{N}x_i^M y_i\end{pmatrix}$$求解上述方程组即可得到拟合多项式系数 $w_0^{\ast},w_1^{\ast},\cdots,w_M^{\ast} $.python代码如下：123456789101112131415161718import numpy as npN = 5 #多项式的阶数def getCoefficientMatrix(x,y): global N MeasureNumber = len(x) A = np.zeros((N+1,N+1)) B = np.zeros(N+1) for i in range(N+1): for j in range(N+1): for k in range(MeasureNumber): A[i, j] += np.math.pow(x[k], i+j) #生成系数矩阵每个系数，可以改进为先求出0次到2(N+1)次方的和，然后一一填入系数矩阵 for k in range(MeasureNumber): B[i] += np.math.pow(x[k], i)*y[k] return A, BA, B = getCoefficientMatrix(x,y)Omega = np.linalg.solve(A,B) #线性方程组求解，自己编程实现可以使用推荐使用共轭梯度]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消去法]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高斯消去法与$LU$分解高斯消去法思想就是通过初等行变换将系数矩阵变换成上三角矩阵，最后一行就解出了最后一个未知数的值，向上回带即可得到结果。计算过程就是第二行开始每一行乘以第一行的$\lambda_{i}$倍，使得每一行第一个系数为0，然后对每一行做同样操作循环下去（下一次从第三行开始，使每一行第二个系数为0），使得系数矩阵变成上三角矩阵。最后回带每个未知量，求得结果。例，对于线性方程组$\boldsymbol{Ax}=\boldsymbol{b}$，其中：$$A=\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix},\quadb=\begin{bmatrix}4 \\11 \\29 \\30\end{bmatrix}.$$计算步骤：$\begin{aligned}(\boldsymbol A |\boldsymbol b)&amp;\xrightarrow{第一次消元}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\0 &amp; 3 &amp; 5 &amp; 5 &amp; 13\\0 &amp; 4 &amp; 6 &amp; 8 &amp; 18\end{bmatrix}\xrightarrow{第二次消元}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\0 &amp; 0 &amp; 2 &amp; 2 &amp; 4\\0 &amp; 0 &amp; 2 &amp; 4 &amp; 6\end{bmatrix}\\&amp;\xrightarrow{第三次消元}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 &amp; 4 \\0 &amp; 1 &amp; 1 &amp; 1 &amp; 3 \\0 &amp; 0 &amp; 2 &amp; 2 &amp; 4\\0 &amp; 0 &amp; 0 &amp; 2 &amp; 2\end{bmatrix}=(\boldsymbol U|\boldsymbol c)\end{aligned}$解上三角方程组$\boldsymbol{Ux}=\boldsymbol{c}$，得方程组得解为$\boldsymbol{x}=(1,1,1,1)^{T}$.上述行变换可以用初等矩阵来描述：$\boldsymbol L_1\boldsymbol A =\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\-2 &amp; 1 &amp; 0 &amp; 0 \\-4 &amp; 0 &amp; 1 &amp; 0 \\-3 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix}=\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 3 &amp; 5 &amp; 5 \\0 &amp; 4 &amp; 6 &amp; 8\end{bmatrix}$$\begin{aligned}\boldsymbol L_2\boldsymbol L_1\boldsymbol A &amp;=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -3 &amp; 1 &amp; 0 \\0 &amp; -4 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\-2 &amp; 1 &amp; 0 &amp; 0 \\-4 &amp; 0 &amp; 1 &amp; 0 \\-3 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix}\\&amp;=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\-2 &amp; 1 &amp; 0 &amp; 0 \\-4 &amp; -3 &amp; 1 &amp; 0 \\-3 &amp; -4 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix}=\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 2 &amp; 2 \\0 &amp; 0 &amp; 2 &amp; 4\end{bmatrix}\end{aligned}$$\begin{aligned}\boldsymbol L_3\boldsymbol L_2\boldsymbol L_1\boldsymbol A &amp;=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; -3 &amp; 1 &amp; 0 \\0 &amp; -4 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\-2 &amp; 1 &amp; 0 &amp; 0 \\-4 &amp; 0 &amp; 1 &amp; 0 \\-3 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix}\\&amp;=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\-2 &amp; 1 &amp; 0 &amp; 0 \\-4 &amp; -3 &amp; 1 &amp; 0 \\-3 &amp; -4 &amp; -1 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\4 &amp; 3 &amp; 3 &amp; 1 \\8 &amp; 7 &amp; 9 &amp; 5 \\6 &amp; 7 &amp; 9 &amp; 8\end{bmatrix}=\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 2 &amp; 2 \\0 &amp; 0 &amp; 0 &amp; 2\end{bmatrix}=\boldsymbol U\end{aligned}$所以：$\boldsymbol A=\boldsymbol L \boldsymbol U=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\2 &amp; 1 &amp; 0 &amp; 0 \\4 &amp; 3 &amp; 1 &amp; 0 \\3 &amp; 4 &amp; 1 &amp; 1\end{bmatrix}\begin{bmatrix}2 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 2 &amp; 2 \\0 &amp; 0 &amp; 0 &amp; 2\end{bmatrix}$高斯消去法先得到上三角矩阵再回代求解，而$LU$分解先对系数矩阵$A$分解成两上下三角矩阵，然后两次回代求解。一般编程语言的科学计算库都是使用$LU$分解求线性方程组。定理 若$n$阶方阵逐次（左上角）主子式$det A_k\neq 0,k=1,2,\cdots,n$，则$A$可以分解为单位下三角矩阵和上三角矩阵。顺序Gauss消去法可以顺利进行。高斯消去法$LU$分解$Ax=b\\ \quad\Downarrow\\Ux=c$$A=LU\\ Ly=b\\Ux=y$如上讨论的是顺序Gauss消去法，即除数$A(k,k)$不为0，或者说除数不能为0。当我们遇到除数$A(k,k)$为0的时候就需要进行行交换，将$A(k,k)=0$时的k行换到下方去。《科学计算和C程序集》的高斯消去法代码：https://github.com/Love-Chrissie/numerical-computation/blob/master/gelim.cpython代码如下:12345678910111213141516171819202122import numpy as np# 输入系数矩阵应以numpy中的array类型输入# LU分解又称doolittle分解def doolittle(a, n): # 主行 l = np.eye(n) u = np.zeros((n, n)) for i in range(n): for j in range(i + 1, n): # 乘子，用于消去第j行的i列 a[j, i] = a[j, i] / a[i, i] # 对i+1...n-1列 for k in range(i + 1, n): a[j, k] = a[j, k] - a[j, i] * a[i, k] # 消元 for i in range(n): for j in range(n): if (j &lt; i): l[i, j] = a[i, j] # 下三角矩阵 else: u[i, j] = a[i, j] # 上三角矩阵 return a,l,u]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵与数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变限积分的导数与雷诺运输定理]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%8F%98%E9%99%90%E7%A7%AF%E5%88%86%E7%9A%84%E5%AF%BC%E6%95%B0%E4%B8%8E%E9%9B%B7%E8%AF%BA%E8%BF%90%E8%BE%93%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[变限积分求导，我是这么俗称这个公式的，维基百科称为积分符号内取微分$$\dfrac{d}{dt}\int\limits_{\alpha(t)}^{\beta(t)} f(x,t)dx=\int\limits_{\alpha(t)}^{\beta(t)} \frac{\partial f(x,t)}{\partial t}dx+\beta^{\prime}(t)f(\beta(t),t)-\alpha^{\prime}(t)f(\alpha(t),t)$$最开始是搞数学竞赛的时候看别的大神炫技学会的，然后看了微积分学教程又巩固了一遍，一般数学分析书都有证明。这个公式在《别闹了，费曼》中也有介绍。变限积分求导公式是个很一般的公式，这里提到它是因为在复习雷诺运输定理的时候发现了他两之间的联系——雷诺运输定理也就是变限积分求导公式的三维情况。雷诺运输定理：对于随时间变化的区域$\Omega (t)$，其边界为$\partial \Omega (t)$，该区域内对$\boldsymbol{f}=\boldsymbol{f}(x,t)$的积分的导数为：$$\dfrac{d}{dt} \big( \int _{\Omega (t)} \boldsymbol{f}\,{dV} \big) =\int _{\Omega (t)} {\frac{\partial \boldsymbol{f}}{\partial t}}\,{dV}+\int _{\partial \Omega (t)} ({\vec {v}} \cdot {\vec {n}} ) \boldsymbol{f}\, {dA} .$$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>导数</tag>
        <tag>积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[范数]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%8C%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[向量范数定义定义：定义在$ {\mathbb{C}}^n $上的一个非负实值函数，记为$\parallel\cdot\parallel$，若该函数满足以下三个条件：即对任意向量$\boldsymbol x$和$\boldsymbol y$以及任意常数$\alpha \in \mathbb{C}$$\parallel \boldsymbol x \parallel\geq 0$,并且$\parallel \boldsymbol x \parallel= 0$的充要条件为$\boldsymbol x =\boldsymbol 0$;$\parallel \alpha \boldsymbol x \parallel=|\alpha|\, \parallel\boldsymbol x\parallel$,$\parallel \boldsymbol x + \boldsymbol y\parallel \leq \parallel\boldsymbol x\parallel+\parallel\boldsymbol y\parallel$,则称$\parallel\cdot\parallel$为上${\mathbb{C}}^n$的一个向量范数一类有用的向量范数为$p$范数，定义为：$$\parallel \boldsymbol x \parallel_{p}=(\sum \limits_{i=1}^{n} |x_i|^{p})^{\frac{1}{p}},\quad p\geq1$$其中最重要的是$1$范数，$2$范数，$\infty$范数$$\begin{align}&amp; \parallel \boldsymbol x \parallel_{1}=\sum \limits_{i=1}^{n} |x_i|;\\&amp; \parallel \boldsymbol x \parallel_{2}=(\sum \limits_{i=0}^{n} |x_i|^{2})^{\frac{1}{2}};\\&amp; \parallel \boldsymbol x \parallel_{\infty}=\max \limits_{1\leq i\leq n} |x_i|.\end{align}$$其中$\infty$范数形式的得出只要利用$p$范数，对$p$取$\infty$即可，证明略。另一常用范数是加权的$p$范数可以表示为：$$\parallel\boldsymbol x\parallel_{\boldsymbol W} =\parallel\boldsymbol{Wx}\parallel,$$其中$\boldsymbol W$为对角矩阵，其对角元即为它每个分量的加权系数，更一般地可以取$\boldsymbol W$为任意非奇异矩阵。性质关于$p$范数的一个经典性质是Hölder不等式：$$\parallel{\boldsymbol x}^{T} \boldsymbol y\parallel_1 \leq \parallel\boldsymbol x\parallel_p \parallel\boldsymbol y\parallel_q,\quad \frac{1}{p}+\frac{1}{q}=1.$$对于$2$范数就是著名的Cauchy–Schwarz不等式:$$\parallel{\boldsymbol x}^{T} \boldsymbol y\parallel_1 \leq \parallel\boldsymbol x\parallel_2 \parallel\boldsymbol y\parallel_2.$$对于$p$范数，其对应的三角不等式即为闵可夫斯基不等式:$$\parallel \boldsymbol x + \boldsymbol y\parallel_p \leq \parallel\boldsymbol x\parallel_p+\parallel\boldsymbol y\parallel_p.$$下面证明之（利用到了Hölder不等式）：$$\begin{align}(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}\cdot p}&amp; = \sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |x_i+y_i| \\&amp; \leq \sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |x_i|+\sum \limits_{i=1}^{n}|x_i+y_i|^{p-1}\cdot |y_i|\\&amp; \leq (\sum \limits_{i=1}^{n}|x_i+y_i|^{q(p-1)})^{\frac{1}{q}}(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+ (\sum \limits_{i=1}^{n}|x_i+y_i|^{q(p-1)})^{\frac{1}{q}}(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}},\,\text{Hölder’s inequality}\\&amp; = \Big[(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}}\Big] (\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}}\end{align}$$两边同时除以$(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{q}}$即可得到闵可夫斯基不等式，如下所示：$$(\sum \limits_{i=1}^{n}|x_i+y_i|^p)^{\frac{1}{p}}\leq(\sum \limits_{i=1}^{n}|x_i|^p)^{\frac{1}{p}}+(\sum \limits_{i=1}^{n}|y_i|^p)^{\frac{1}{p}}$$范数的等价性范数的等价性定理：设$\parallel\cdot\parallel_{\alpha}$和$\parallel\cdot\parallel_{\beta}$为${\mathbb{C}}^n$上的任意两种向量范数，则存在两个与向量$\parallel\boldsymbol x\parallel$无关的正常数$c_1$和$c_2$，使得下面的不等式成立：$$c_1 \parallel\boldsymbol x\parallel_{\beta}\leq \parallel\boldsymbol x\parallel_{\alpha}\leq c_2 \parallel\boldsymbol x\parallel_{\beta},\quad \boldsymbol x \in {\mathbb{C}}^{\,n}$$并称$\parallel \cdot \parallel_{\alpha}$和$\parallel \cdot \parallel_{\beta}$为${\mathbb{C}}^{\, n}$上的等价范数。以下为三个常见不等式：$\parallel\boldsymbol x\parallel_{\infty}\leq\parallel\boldsymbol x\parallel_1\leq n\parallel\boldsymbol x\parallel_{\infty}$;$\frac{1}{\sqrt n}\parallel\boldsymbol x\parallel_1\leq\parallel\boldsymbol x\parallel_2\leq \parallel\boldsymbol x\parallel_1$;$\frac{1}{\sqrt n}\parallel\boldsymbol x\parallel_2\leq\parallel\boldsymbol x\parallel_{\infty}\leq \parallel\boldsymbol x\parallel_2$.矩阵范数定义一个$m\times n$矩阵可以看成$mn$维向量空间中的一个向量，故矩阵范数的定义等价于向量范数的定义。定义：定义在${\mathbb{C}}^{m\times n}$上的一个非负实值函数，记为$\parallel\cdot\parallel$。若$\forall \boldsymbol A,\boldsymbol B\in {\mathbb{C}}^{m\times n}$均满足以下条件：非负性：$\parallel \boldsymbol A \parallel\geq 0$,并且$\parallel \boldsymbol A \parallel= 0$的充要条件为$\boldsymbol A =\boldsymbol 0$;齐次性：$\parallel \alpha \boldsymbol A \parallel=|\alpha|\, \parallel\boldsymbol A\parallel,c\in \mathbb{C}$三角不等式：$\parallel \boldsymbol A + \boldsymbol B\parallel \leq \parallel\boldsymbol A\parallel+\parallel\boldsymbol B\parallel$,则称$\parallel\cdot\parallel$为${\mathbb{C}}^{m\times n}$上的矩阵范数。相容性：如果对所有$\boldsymbol A\in \mathbb{R}^{m\times n}$和$\boldsymbol B\in \mathbb{R}^{n\times q}$有$f_1 (\boldsymbol{AB})\leq f_2 (\boldsymbol A)f_3 (\boldsymbol B)$，则称$\mathbb{R}^{m\times q}$，$\mathbb{R}^{m\times n}$和$\mathbb{R}^{n\times q}$上的范数$f_1$，$f_2$和$f_3$是相互相容的。有的书上矩阵范数特指满足相容性条件的范数。下面考虑的矩阵范数均是满足相容性的矩阵范数。其中最常用的矩阵范数有$F$范数（Frobenius范数）：$$\parallel\boldsymbol A\parallel_{F}=\sqrt{\sum\limits_{i=1}^m \sum\limits_{j=1}^n |a_{ij}|^2}$$和$p$范数:$$\parallel\boldsymbol A\parallel_{p}=\sup\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\frac{\parallel\boldsymbol{Ax}\parallel_p}{\parallel\boldsymbol x\parallel_p}$$很明显，$\parallel\boldsymbol A\parallel_p$是将$\boldsymbol A$作用到$p$范数单位向量所得到的最大向量的$p$范数：由向量范数导出矩阵范数给定$\mathbb{C}^n$上的向量范数$\parallel\cdot\parallel$，$\boldsymbol A$为$m\times n$矩阵，定义：$$\parallel\boldsymbol{A}\parallel=\sup\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\bigg(\frac{\parallel\boldsymbol {Ax}\parallel}{\parallel\boldsymbol x\parallel}\bigg)=\sup_{\parallel\boldsymbol{x}\parallel=1}{\parallel\boldsymbol {Ax}\parallel}$$并称$\parallel\cdot\parallel$为向量范数诱导的矩阵范数，简称算子范数。p-范数诱导的矩阵范数$\mathbb{C}^m$和$\mathbb{C}^n$空间上装备的向量范数都是$p$范数时，其诱导的矩阵范数也称为诱导$p$范数$$\parallel \boldsymbol{A} \parallel_{p}=\sup\limits_{x \neq 0}\parallel\boldsymbol{A}\Big(\frac{\boldsymbol x}{ \parallel\boldsymbol x \parallel_p}\Big)\parallel_p=\max \limits_{\parallel\boldsymbol x\parallel_p=1}\parallel\boldsymbol{Ax}\parallel_p=\max\limits_{\boldsymbol{x} \neq \boldsymbol{0}}\frac{\Big(\sum\limits_{i=1}^{n}|\sum\limits_{j=1}^{m}A_{ij}x_j|^p\Big)^{\frac{1}{p}}}{(\sum\limits_{i=1}^{m}|x_i|^p)^{\frac{1}{p}}}.$$对于诱导$p$范数，有三种常用范数：$\parallel \boldsymbol{A} \parallel_{1}=\max\limits_{1\leq j\leq n}\sum\limits_{i=1}^{m}|a_{ij}|;$$\parallel \boldsymbol{A} \parallel_{2}=\sqrt{\lambda_{\max}(\boldsymbol{A^{H}A})}$$\parallel \boldsymbol{A} \parallel_{\infty}=\max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|;$这里给出3的证明$$\parallel \boldsymbol{Ax} \parallel_{\infty}=\max \limits_{1\leq i\leq n}\big|\sum\limits_{j=1}^{n}a_{ij}x_j\big|\leq \max \limits_{1\leq i\leq n}\sum\limits_{j=1}^{n}|a_{ij}x_j|\leq\max \limits_{1\leq i\leq n}\sum\limits_{j=1}^{n}|a_{ij}|\parallel \boldsymbol x\parallel_{\infty} \leq \parallel A \parallel_{\infty}\parallel \boldsymbol x \parallel_{\infty},$$因此:$$\parallel \boldsymbol A \parallel_{\infty}=\max\limits_{\boldsymbol{x}\neq\boldsymbol{0}}\frac{\parallel \boldsymbol{Ax}\parallel_{\infty}}{\parallel \boldsymbol{x}\parallel_{\infty}}\leq \max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|$$假定$\boldsymbol A$的第$k$行非零，且定义向量$z\in\mathbb{C}^n$为:于是$\parallel \boldsymbol z \parallel_{\infty}=1$，且对所有$j=1,2,\dots ,n$，有$a_{kj}z_{j}=|a_{kj}|$，并且$$\max\limits_{\parallel \boldsymbol x\parallel_{\infty}=1}\parallel \boldsymbol{Ax}\parallel_{\infty}\geq\parallel \boldsymbol{Az}\parallel_{\infty}=\max\limits_{1\leq i\leq n}\big|\sum\limits_{j=1}^{n}a_{ij}z_{j}\big|\geq\big|\sum\limits_{j=1}^{n}a_{kj}z_{j}\big|=\sum\limits_{j=1}^{n}|a_{kj}|.$$因此$$\max\limits_{\parallel \boldsymbol x\parallel_{\infty}=1}\parallel \boldsymbol{Ax}\parallel_{\infty}\geq \max\limits_{1\leq i\leq m}\sum\limits_{j=1}^{n}|a_{ij}|$$对于以上三个矩阵范数，我们有：$$\parallel \boldsymbol{A} \parallel _{2}^{2} \leq\parallel \boldsymbol{A} \parallel _{1}\, \parallel \boldsymbol{A} \parallel _{\infty}$$推论 对任何算子范数，单位矩阵$\boldsymbol I$的范数为1。练习：设$\boldsymbol A$为n阶非奇异矩阵，$\boldsymbol U$为n阶酉矩阵,，证明：$\parallel \boldsymbol U\parallel_2=1$;$\parallel \boldsymbol{AU}\parallel_2=\parallel \boldsymbol{UA}\parallel_2=\parallel \boldsymbol{A}\parallel_2$;$\parallel \boldsymbol{A}\parallel_F=\parallel \boldsymbol{UA}\parallel_F=\parallel \boldsymbol{AV}\parallel_F=\parallel \boldsymbol{UAV}\parallel_F$定义：矩阵$\boldsymbol A$的谱为：$\sigma(\boldsymbol{A})=$ &#123; $\lambda \big|\lambda $为$\boldsymbol{A}$的特征值 &#125;。矩阵$\boldsymbol A$的谱半径为：$\rho(\boldsymbol{A})=\max$ &#123; $|\lambda| \big|\lambda $为$\boldsymbol{A}$的特征值 &#125;。定理 设$\parallel\cdot\parallel$为$\mathbb{C}^{n\times n}$矩阵空间的一种矩阵范数，则对任意的n阶方阵$\boldsymbol A$均有：$$\rho(\boldsymbol A)\leq \parallel \boldsymbol A \parallel.$$特别的，当$\boldsymbol A$为对称矩阵时:$$\rho(\boldsymbol A)=\parallel \boldsymbol A \parallel_{2}.$$定理 对于任意$\varepsilon &gt; 0$,存在$\mathbb{C}^{n\times n}$矩阵空间的一种算子范数$\parallel\cdot\parallel$有：$$\parallel \boldsymbol A \parallel\leq\rho(\boldsymbol A)+\varepsilon.$$定理 设$\boldsymbol A \in \mathbb{C}^{n\times n}$，如果有$\mathbb{C}^{n\times n}$上的一种矩阵范数$\parallel\cdot\parallel$使得$\parallel \boldsymbol A\parallel &lt; 1$，则：矩阵$\boldsymbol I \pm \boldsymbol A$可逆；$\parallel(\boldsymbol I \pm \boldsymbol A)^{-1}\parallel \leq \frac{\parallel \boldsymbol I \parallel}{1-\parallel \boldsymbol A \parallel}$$\parallel \boldsymbol{A}(\boldsymbol I \pm \boldsymbol A)^{-1}\parallel \leq \frac{\parallel \boldsymbol A \parallel}{1-\parallel \boldsymbol A \parallel}$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵与数值分析</tag>
        <tag>范数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fusc function problem of Kata]]></title>
    <url>%2F2018%2F09%2F23%2FfuscFunction%2F</url>
    <content type="text"><![CDATA[This Kata is a continuation of Part 1. The fusc function is defined recursively as follows:1234fusc(0) = 0fusc(1) = 1fusc(2n) = fusc(n)fusc(2n + 1) = fusc(n) + fusc(n + 1)Your job is to produce the code for the fusc function. In this kata, your function will be tested with large values of n (more than 1000 bits), so you should be concerned about stack overflow and timeouts.NOTE: In JavaScript and PHP, your function will be tested with n up to 52 bits. This will still require a non-naive solution. This will also overflow 32-bit operators, but it will be integer arithmetic.Hint: Define F(n, a, b) = a * fusc(n) + b * fusc(n + 1) and provide a recursive definition of F without referencing fusc.上面是我之前做这题时候的描述，现在再看这题，题目描述都不一样了。。之前直接递归可能是测试数太大了，直接超出最大递归深度。现在这题改了可以通过了，代码就不贴了。但是之前谷歌搜了半天搜到了一个叫Stern’s Diatomic Series的东西，很有意思，这个递推公式的通项可以写成如下形式：$$ a_{0}=0,a_{1}=1,a_{n}=\sum_{k=0}^{n-1}\limits \binom{k}{n-k-1}(mod\,2). $$]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>Kata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无理数小数部分的稠密性]]></title>
    <url>%2F2018%2F09%2F23%2F%E4%B8%80%E9%81%93%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E9%A2%98%2F</url>
    <content type="text"><![CDATA[引理: $s·k$ 的小数部分在区间$[0,1]$上稠密，其中$s$为无理数，$k$为整数。$prove:$即证明对任意正整数$m$，存在整数k使得 0 &#60; &#123; $ks$ &#125; &#60; $\frac {1} {m} $。将[0,1]区间分成m份$[0,\frac{1}{m})$，$[\frac{1}{m},\frac{2}{m})$ ，$\cdots$，$[\frac{m-1}{m},1]$，由抽屉原理可知，对于序列 &#123; &#123; $ts$ &#125; &#125; ,$(t=1,2,\cdots,m+1)$至少存在两者位于同一个小段区间内，假设为&#123; $ps$ &#125;, &#123; $qs$ &#125;，即0 &#60; &#123;$ps$&#125; $-$ &#123;$qs$&#125; &#60; $\frac{1}{m}$.取$k=p-q$即可。问题：证明$\lim \limits_{x\rightarrow0^+} \frac{1}{x}-\lfloor \frac{1}{x} \rfloor$极限不存在。$prove:$设$s$为无理数，$k$为正整数$(k=1,2,\cdots,n,\cdots)$。取$x=\frac{1}{ks}$，由引理知序列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;在$[0,1]$内稠密，故序列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;极限不存在，即$x\rightarrow 0^+ $时，存在子列&#123; $ks$$-$$\lfloor$ $ks$ $\rfloor$ &#125;，极限不存在，即$\lim \limits_{x\rightarrow0^+} \frac{1}{x}-\lfloor \frac{1}{x} \rfloor$极限不存在。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>无理数</tag>
        <tag>稠密性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合问题递归实现]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[组合问题递归实现问题：在n个不同物体中选取k个，列举出所有选取情况。思路很简单就是按照数数的方式把每种情况数出来，也就是第一次选取一个物体，第二次在剩余的中选取一个，直到选取k个。用数学公式就是帕斯卡公式$$C_{n}^{k}=C_{n}^{k-1}+C_{n-1}^{k-1}\Rightarrow C_{n}^{k}=\sum \limits_{s=0}^{k-1}{k-1 \choose s}C_{n-s}^{1}$$Python代码实现：123456789101112'''project为n个不同的物体'''def combine(project, n, k, K, lst2): for i in range(n, k-1, -1): lst2[k-1] = i-1 if k&gt;1: combine(project, i-1, k-1, K, lst2) else: for j in range(K-1,-1,-1): print(project[lst2[j]],end='') print("\n")]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老鼠和毒药]]></title>
    <url>%2F2018%2F09%2F23%2F%E8%80%81%E9%BC%A0%E5%92%8C%E6%AF%92%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？思考：我们有100个囚犯，这100个囚犯要枪毙。首先100个囚犯站一排报数，报到奇数就枪毙，报到偶数就留下，留下之后再站一排，然后同样规则继续枪毙，直到剩下一个人就把它放了，问：如果你想要被放掉，你最开始应该站在什么位置？推广：如果你有两个星期的时间（换句话说你可以做两轮实验），为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？注意，在第一轮实验中死掉的老鼠，就无法继续参与第二次实验了。答案：点击查看将1000个瓶子按0～999标号并表示成10位二进制数的形式，第一个老鼠喝所有瓶子编号第一位为1的瓶子，第二个老鼠喝所有瓶子编号第二位为1的瓶子，以此类推，第十个老鼠就喝所有瓶子编号第十位为1的瓶子。一星期后，第几只老鼠死了就在第几位上写下1，没死就写上0，这样就得到瓶子的编号了，很明显10只老鼠最大验证毒药瓶子数为$2^{10}=1024$。思考：64号位置，枪毙规律就是100个编号(1,2,$\cdots$,100)无限次每次地板除2，每次保留没有余数的，直到只剩一个数为止，余下的那个数这必然是$2^n$。推广自行思考。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关hexo写latex数学公式的一些雷区]]></title>
    <url>%2F2018%2F09%2F23%2Fmarkdown%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[特殊符号的转义问题在markdown中使用latex数学公式时候，不可在数学公式环境下&#40; &#36;&#36;包括进去的部分 &#41;使用&#92;进行转义，否则hexo生成会报错。比如大括号&#123;，不要在数学公式环境内使用&#92;&#123;转义，而应该使用&amp;#123;。一些markdown需要转义字符如下：符号html代码注释&#33;&amp;#33;惊叹号&#34;&amp;#34;双引号&#35;&amp;#35;数字标志&#36;&amp;#36;百分号&#37;&amp;#37;单引号&#38;&amp;#38;左小括号&#39;&amp;#39;右小括号&#40;&amp;#40;惊叹号&#41;&amp;#41;加号&#42;&amp;#42;小于号&#43;&amp;#43;等于号&#60;&amp;#60;大于号&#61;&amp;#61;问号&#64;&amp;#64;Commercial at&#91;&amp;#91;左中括号&#92;&amp;#92;反斜杠&#93;&amp;#93;右中括号&#123;&amp;#123;左大括号&#124;&amp;#124;竖线&#125;&amp;#125;右大括号数学环境下的换行问题我们需要\\\\（四个）而不是\\（俩个）实现换行，因为markdown会将反斜杠视作转义]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>latex</tag>
      </tags>
  </entry>
</search>
